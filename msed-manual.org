#+TITLE: Medley Sound editor V1.0 manual
#+SUBTITLE: a product of trial and error, and lots of reverse enginerding
#+AUTHOR: Lauri "Archyx" Lindholm
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper]

* Medley Sound editor V1.0 manual

Medley Sound is the software that was used to make the background
music for the Imploder 4.0.  The two songs used in it were called
"Plodemusic" and "requester deun", the first one being the main theme
tune and latter was the tune that played after the file implosion was
done and the save requester was shown.  The Meter Test feature in the
score editor was for fine tuning the meters in Imploder 4.0 to wiggle
with the theme tune.

This manual is a creation based on a lot of experimentation and a lot
more reverse engineering of the Medley Sound player routine and the
editor.  All of this was written because the original complete source
code and whatever documentation there had been was partially lost
prior to Paul releasing what little was left of this historical
software.

The editor doesn't have a very polished interface and plenty of the
values for various parameters just have to be known.  This manual is
an attempt to document these various parameters and their functional
values to make the editor useful once again.

In July 2024 the internal data structures of the executable programs
were split out of the editor manual as the file size started to grow.
They can now be found from a separate document in the repository.


** Some common commands and data input schemes

The different parts of the editor share certain common commands and
data input schemes.  The typical commands are as follows:

|-------------+------------------------------------------------|
| ~c~         | Change (or select) instrument/score/track/wave |
| ~r~         | Rename instrument/score/track/wave             |
| Shift + ~K~ | Delete ("kill")                                |
| Shift + ~N~ | Allocate new                                   |
| <SPC>       | Notes off / stop                               |
| <ESC>       | Cancel input/operation, exit editor            |
| Ctrl + ~L~  | Switch hardware low-pass filter on/off ("LED") |
| Ctrl + ~V~  | Open supervisor console                        |
|-------------+------------------------------------------------|

Not all of these commands work in every editor, but most do.

One thing to keep in mind is that the editor is designed to be used
with the default ~us~ keymap.


*** Number entry

A typical single-byte number entry uses the typewriter keyboard to
input individual hexadecimal numbers.  The current number in the
single digit position is pushed into tens and the number in tens is
discarded.  The ~1~ to ~9~ on the numpad are used in a special way to
modify the existing hex number:

+-----+-----+-----+-----+
|  [  |  ]  |  /  |  *  |
+-----+-----+-----+-----+
| -10 | $ff | +10 |  -  |
+-----+-----+-----+-----+
|  -4 | $80 |  +4 |  +  |
+-----+-----+-----+-----+
|  -1 | $00 |  +1 |  E  |
+-----+-----+-----+  n  |
|    0      |  .  |  t  |
+-----------+-----+-----+


** Supervisor

The editor features a "Supervisor" console from which certain
statistics can be viewed.  It also features optimising tools to delete
unused tracks, instruments, and waves to reduce memory footprint.

However, at least some of these optimising tools have logic flaws
which render the tools useless in their current implementation and may
cause deletion of all tracks/instruments/waves instead of just the
unused ones.

The score optimiser can potentially corrupt memory in addition to
plain clearing the score table without freeing the allocated memory.


*** ~i~ – info

Shows basic information about the current song in memory.


*** ~l~ – list

This command is used to list allocated instruments, scores, tracks, or
waves in the Supervisor console.  ~l~ alone does nothing.  See table
below.

|------+----------------------|
| ~li~ | List instruments     |
| ~ls~ | List scores          |
| ~lt~ | List tracks          |
| ~lw~ | List waves (samples) |
|------+----------------------|


*** ~m~ and ~v~ – monitor and view

Monitor and View are basically the same thing. The difference is that
View displays a single frame of player status while Monitor refreshes
the status display continuously.

: Enable ff   Flang Algo 03  Flang Speed 06  Volume 3f
:
: 0:on   C..3  02  ins 09 dbass2           Vol 3f
: 1:on   C..2  2b  ins 06 Carrilon         Vol 3f
: 2:on   C..3  42  ins 09 dbass2           Vol 31
: 3:on   E..2  06  ins 09 Snaredrum        Vol 3f

The first line shows player interrupt status, flanger algorithm and
speed, and the song volume.

The data shown for each channel is channel status (~on~ or ~off~), the
note, the play time of the note left, the instrument number and name,
and volume.


*** ~o~ – optimise

These commmands are used to clean up unused song parts before
exporting the song into assembly source.

Since these functions can be very unreliable, it's preferred to use an
external tool to convert a PVMS project selectively into an MSOB.
This document contains all the information needed to create such a
tool.


**** ~os~ – Optimise scores

**Do not use!** This feature is broken!  Initially it looked like it
might write to undefined memory, but it still uses an uninitialised
counter.  The executable should be patched first for this function to
operate correctly.

The intention of score optimisation is to move all allocated scores
one after another into a contiguous list.  Due to a bug that
initialises an incorrect register instead of the one used for the
counter, this function might not scan through the whole score table.


**** ~oa~ - Optimise all

Performs the following optimisations in order:

1. Optimise tracks.
2. Optimise instruments.
3. Optimise waves.


**** ~ot~ - Optimise tracks

Scans through all tracks used in scores and any tracks used by tracks
used in scores and deletes all the tracks not referenced to.


**** ~oi~ – Optimise instruments

Scans through all scores and tracks for any used instruments and
deletes any instruments not used.


**** ~ow~ – Optimise waves

Scans through all instruments and deletes all unused waves.


* Main Menu

** (m) Medley Editor

The Medley Editor is not implemented.


** (s) Score Editor

The Score Editor is used to define the four tracks and other
parameters that make each of 255 possible songs, $1..$ff.


** (t) Track Editor

The Track Editor is used to create and edit tracks, the maximum number
of them being 255, $1..$ff.  Tracks are pieces of single channel note
and control data and run independently from each other.  Proper timing
of tracks between channels is solely left to the song programmer,
which allows great flexibility to reuse tracks efficiently.


** (i) Instrument Editor

The Instrument Editor is used to define instrument parameters.  There
can be a maximum number of 255 instruments, $1..$ff, each using 1 to 8
waves defined by an octave table, a single volume envelope generator,
and four modulation generators.  Three operating modes are available
to produce sounds from plain samples to complex dynamic synthesis.


** (w) Wave Editor

The Wave Editor is also known as the Sample Editor.  The Wave Editor
has facilities to generate pulse and triangle/saw waves, or a
precalculated sine wave, and an operation mode to edit and mix waves
together.


** (c) Chord Editor

The Chord Editor is not implemented.  It could be speculated that the
intention was to create an arpeggiator similar to the Future Player
implementation.


** (f) File Menu

The File Menu offers the usual project loading and saving as well as a
special option to export the song as an assembly language source code.
Assembling the source will produce a Medley Sound Object, or MSOB, for
use with the standalone player.


** (Q) Quit

To quit Medley Sound Editor you must press ~Shift + Q~.  If you press
just ~q~, the editor will show "Say what?" on the window title.
Pressing ~Esc~ will instruct "Shift-Q to Quit" in the window title.


* Score Editor

The Score Editor defines the starting tracks of the song played on the
four channels.  See Track Editor and the TRACK command to figure out
how to nest tracks to make a song out of multiple tracks.

A starting track, a default instrument, FxBase, FxRnd, and channel
volume are defined for each channel.  FxBase and FxRnd are discussed
further in a following section.  The channel volume appears to be a
non-functional variable.

*Note!* If you have song repeat enabled, the player routine will
become stuck in an endless loop if a starting track on any channel
contains no notes or only zero-length notes.  This will freeze the
whole computer!

Setting volumes and other score variables is typically not boundary
checked, which means the song programmer needs to take care that the
variables are within functional limits, eg. volumes are between 0 and
$3f.


** Keyboard commands

|-------------+------------------------------------------------------------------|
| <space>     | Stop playing                                                     |
| ~1~ .. ~4~  | Select channel                                                   |
| ~=~         | Fast forward ("Advance")                                         |
| ~a~         | Set Fl. Algo ([[se_flalgo][flanger algorithm]], $01..$05, or $00 = off)         |
| ~b~         | Set FxBase, see [[se_fx][Sound effects]]                                    |
| ~c~         | Change score                                                     |
| ~d~         | Set default instrument (Def. Ins)                                |
| Shift + ~D~ | Go to Instrument Editor, edit default instrument                 |
| ~h~         | Set Tempo Hi                                                     |
| ~i~         | Set instrument (on selected channel)                             |
| Shift + ~I~ | Go to Instrument Editor, edit instrument set on selected channel |
| Shift + ~K~ | Delete score                                                     |
| ~l~         | Set Tempo Lo                                                     |
| ~m~         | Meter test (nothing to see unless a song is playing)             |
| ~n~         | Set FxRnd, see [[se_fx][Sound effects]]                                     |
| Shift + ~N~ | Allocate new score                                               |
| ~o~         | Set Transpose                                                    |
| ~p~         | Play song                                                        |
| Shift + ~P~ | Play From:                                                       |
| ~r~         | Rename score                                                     |
| Shift + ~R~ | Set song repeat (boolean, $00 = off, $ff = on)                   |
| ~s~         | Set Fl. Speed                                                    |
| ~t~         | Set track on selected channel                                    |
| Shift + ~T~ | Go to Track Editor, edit track set on selected channel           |
| ~u~         | Set Upd Reduc                                                    |
| Shift + ~U~ | Unchord (useful mainly with tracks imported from SMUS files)     |
| ~v~         | Set channel volume (Not implemented in the player!)              |
| Shift + ~V~ | Set song volume                                                  |
| Shift + ~X~ | Exchange tracks with secondary track set                         |
|-------------+------------------------------------------------------------------|

Notes:

- Secondary tracks are not used by the player.  (Or it's something for
  the "Medley" feature that was never implemented.)

- The Meter Test shows a mockup of Imploder 4.0 meters on top of the
  score editor.  The drum instrument numbers are hardcoded against
  preset meter deflections.  Other meter modes calculate deflection
  dynamically from a combination of note and note duration.

  The two meters on the left are channels 1 and 4, the middle meter is
  a combined "level" meter, and the two meters on the right are
  channels 2 and 3.


** Flanger

The flanger effect is implemented as changing channel detunes.  To
enable the flanger effect the Flang Speed and Flang Algorithm must be
set non-zero.  The Flang Speed is defined as an initial countdown
value, ie. higher values deliver a slower effect.

The flanger update is performed in the player interrupt code which
makes the Flang Speed definition be "update every nth interrupt
trigger", which also makes it relative to tempo.


*** <<se_flalgo>>Flanger algorithms

The five flanger algorithms are defined in the player routine as
follows:

|------+------+------+------+------|
| alg# | ch 0 | ch 1 | ch 2 | ch 3 |
|------+------+------+------+------|
|    1 |   +1 |   +1 |   ±0 |   ±0 |
|      |   ±0 |   ±0 |   +1 |   +1 |
|------+------+------+------+------|
|    2 |   ±0 |   +1 |   +2 |   -1 |
|      |   +1 |   ±0 |   -1 |   +2 |
|------+------+------+------+------|
|    3 |   ±0 |   +1 |   +2 |   -1 |
|      |   +1 |   +2 |   -1 |   ±0 |
|      |   +2 |   -1 |   ±0 |   +1 |
|      |   -1 |   ±0 |   +1 |   +2 |
|------+------+------+------+------|
|    4 |   ±0 |   ±0 |   -2 |   +2 |
|      |   +1 |   -1 |   -1 |   +1 |
|      |   +2 |   -2 |   ±0 |   ±0 |
|      |   +1 |   -1 |   -1 |   +1 |
|------+------+------+------+------|
|    5 |   -2 |   -1 |   ±0 |   +1 |
|      |   -1 |   ±0 |   +1 |   +2 |
|      |   ±0 |   +1 |   +2 |   -1 |
|      |   +1 |   +2 |   -1 |   -2 |
|------+------+------+------+------|

The algorithms are always defined as a multiple of four bytes, one for
each channel.  Setting the algorithm 0 or beyond 5 will disable the
effect.


** TODO <<se_fx>>Sound effects

Medley Sound was designed for game music and sound effects, so there
naturally is support for the sound effects in the music player.
FxBase ("effect time base") and FxRnd (channel stealing time
randomisation) are used to select sound channels for sound effects as
well as randomising the "channel stealing" and how long a channel is
kept "stolen".  In Future Player the single sound effect channel was
fixed and required constructing the music around this limitation.

This feature requires more research.  For plain music playing the Fx
parameters should be set to 0.


* Track Editor

** Keboard commands

*** Editing modes

|-------------+------------------------|
| Shift + ~D~ | Edit Duration          |
| Shift + ~E~ | Edit Tone and Duration |
| Shift + ~I~ | Insert Mode            |
| Shift + ~L~ | List Mode              |
| Shift + ~T~ | Edit Tone              |
|-------------+------------------------|

The set editing mode of a track persists for the track over track
changes and will also be saved into the project file.  Remember to
change a track back to *List Mode* when you're done editing to avoid
accidental edits!


*** Insert and edit mode functions

|------------------+--------------------------------------------------------|
| Return           | add line below (in insert mode)                        |
| Shift + Return   | insert line above (in insert mode)                     |
| ~a~ .. ~g~       | set note                                               |
| ~1~ .. ~9~       | set octave for note                                    |
| ~`~ (back-quote) | tie note (an asterisk shown before the note)           |
| ~!~              | [[te_TSIGN][TSIGN]] – set time signature (editor feature)            |
| ~@~              | [[te_DYNLV][DYNLV]] – set volume                                     |
| ~#~              | [[te_INSTR][INSTR]] – set instrument                                 |
| ~$~              | [[te_UDATA][UDATA]] – jump to a random track                         |
| ~%~              | [[te_TRACK][TRACK]] – "gosub" to a track                             |
| ~^~              | [[te_RPEAT][RPEAT]] – set start of a loop and loop count             |
| ~&~              | [[te_LOOP][LOOP]] – jump back to a loop start                       |
| ~*~              | [[te_TRANSP][TRANSP]] – transpose up or down in semitones             |
| ~+~              | ~++++~                                                 |
| ~_~ (underscore) | rest ~----~                                            |
| ~-~              | semitone down                                          |
| ~=  ('+')~       | semitone up (buggy sanity-check, don't go beyond B-9!) |
| ~t~              | Trace mode (see notes below)                           |
| Amiga + ~b~      | Set block                                              |
| Amiga + ~c~      | Copy block                                             |
| Amiga + ~i~      | Insert block                                           |
| Amiga + ~k~      | Kill line to buffer                                    |
| Amiga + ~l~      | Yank line from buffer                                  |
| Amiga + ~x~      | Cut block                                              |
| Home (numpad)    | Page up                                                |
| End (numpad)     | Page down                                              |
| Shift + Home     | Go to start of track                                   |
| Shift + End      | Go to end of track                                     |
|------------------+--------------------------------------------------------|

Track navigation is performed using the numpad instead of cursor keys.

Trace mode only works on tracks playing on channel one.  That means
you can't "trace" any other channel while playing a whole score.
Tracing is also rather choppy, so it doesn't work as a real-time
visual view like the pattern view of ProTracker.


** Note editing and SCODEs

Each line of a track represents a note and its length or a control
code (SCODE, most likely from Dutch "stuurcode") and its operand.


*** Notes ($00..$7f)

Notes are defined starting from ~C-1~ ($02 in track data) up to ~B-9~
($6d).  ~----~ ($00) is a rest that triggers ADSR release phase and
~++++~ ($01) is a non-implemented feature.

The operand for a note or a rest is its length, up to $7f.  Bit 7 of
the operand specifies a tied note, ie. inhibit retriggering of the
envelopes or modulation generator(s).  Tying notes together allows a
theoretical infinite note length.

When using the beat and bar signs of the track editor, note length of
$60 will match a whole note.  See [[te_TSIGN][TSIGN]] to adjust time signature.

| note      | length | dotted | triplet |
|-----------+--------+--------+---------|
| whole     | $60    |        |         |
| half      | $30    | $48    | $20     |
| quarter   | $18    | $24    | $10     |
| eighth    | $0c    | $12    | $08     |
| sixteenth | $06    | $09    | $04     |
| 1/32      | $03    |        | $02     |

Comparing to ProTracker patterns at VBlank speed 6, the timing is as
follows:

: ___PT___    ___ Medley Sound ___
: dec  hex    note length
:
:  00 = 00 == $00
:  01   01    $06   sixteenth
:  02   02    $0c   eighth
:  03   03    $12   dotted eighth
:  04 - 04 -- $18 - quarter
:  05   05    $1e
:  06   06    $24   dotted quarter
:  07   07    $2a
:  08 - 08 -- $30 - half
:  09   09    $36
:  10   0A    $3c
:  11   0B    $42
:  12 - 0C -- $48 - dotted half
:  13   0D    $4e
:  14   0E    $54
:  15   0F    $5a
:  16 = 10 == $60 = whole
:  17   11    $66
:  18   12    $6c
:  19   13    $72
:  20 - 14 -- $78
:  21   15    $7e


*** SCODEs ($80..$8f)

The control commands are internally known as SCODEs.  The existing
implementation of the player has a jump table for control codes from
$80 to $8f.  Setting a control code beyond $8f will cause the player
routine to jump to an undefined memory location.


**** $80 [end]

The unmodifyable SCODE is $80 and it's strictly reserved to end a
track.  The operand (always $00) is discarded by the player.

Track nesting table is checked at the track end and replay is resumed
from the calling track, if any.  If there is no track to return to,
song repeat flag is checked and if true, the track restarts.


**** <<te_TSIGN>>$81 TSIGN

This SCODE is ignored by the player.  It exists solely to make the
beat and bar indicators in the track editor functional.  The beat/bar
indicators don't handle TRACK commands which may break the beat count
when other tracks are called within the track.

The operand is 5+3 bit designation for the time signature.  The lower
three bits designate the length of the beat and the upper five bits
the count.  See table below.

+-----+-------+---+------+-----+
| $00 | x/1   |   | $00  | 1/x |
| $01 | x/2   |   | $08  | 2/x |
| $02 | x/4   |   | $10  | 3/x |
| $03 | x/8   |   | $18  | 4/x |
| $04 | x/16  |   | $20  | 5/x |
| $05 | x/32  |   | $28  | 6/x |
| $06 | x/64  |   | $30  | 7/x |
| $07 | x/128 |   | etc. |     |
+-----+-------+---+------+-----+

To set up the time signature 4/4, you'd take $18 from the right side
and add $02 from the left side, $18 + $02 = $1a.

For 6/8 the numbers would be $28 + $03 = $2b.

**Note!** 1/128 ($07) is known to crash the editor!


**** <<te_DYNLV>>$82 DYNLV

This sets the channel volume ("dynamic level").  The operand is
specified between $00 and $7f.  The replay routine will divide this by
two (with logical bitwise shift to right) and discard the least
significant bit.


**** <<te_INSTR>>$83 INSTR

Set instrument on current track. This should be rather
self-explanatory.


**** <<te_UDATA>>$84 UDATA

Note!  The implementation of UDATA is broken in the standalone Medley
Sound Player (msplay)!  Msplay's UDATA handler performs address
displacement calculation incorrectly and jumps to an arbitrary
location in track data.

The name of this SCODE isn't very clear regarding its function.  This
one is used to pick a random track from a specified number of
following TRACK lines.  Use of this SCODE must be carefully considered
because the replay routine doesn't sanity check the following track
data and the editor doesn't prevent entering non-functional data.

The operand should be a power of two, ie. $02, $04, $08, $10, $20,
$40, or $80.  Using any other value is not of use due to how the SCODE
handler is written.

This is how to use UDATA:

|------+-----------------+----------------------------|
| data | in track editor | description                |
|------+-----------------+----------------------------|
| 8404 | UDATA  04       | line count following UDATA |
| 8511 | TRACK  11       | first line                 |
| 8512 | TRACK  12       | second line                |
| 8513 | TRACK  13       | third line                 |
| 8514 | TRACK  14       | fourth line                |
|------+-----------------+----------------------------|

UDATA doesn't affect track nesting the way ordinary use of TRACK does.
This is because the actual SCODE of the lines following UDATA is
ignored, only the operand is used, and when valid the player continues
from the selected track without modification to the nesting tables.

This also means that any lines beyond will be ignored unless an
undefined track is specified.  In case of an undefined track, UDATA
returns as if the operand was $00 and the player continues processing
the following lines in order.

Using UDATA within RPEAT/LOOP can also provide unexpected behaviour as
LOOP will return to playing from the track where the RPEAT originally
was!  However, with careful design this feature can also be used to
create eg. drum tracks with pseudo-randomised fills at the ends.

Since Medley Sound no longer has Future Player's dedicated "jump to
track" command, UDATA can also be used to replace it by using UDATA
with operand $01:

|------+----------------------+-------------|
| data | track data in editor | description |
|------+----------------------+-------------|
| 8401 | UDATA  01            | jump to     |
| 8511 | TRACK  11            | track 11    |
|------+----------------------+-------------|


**** <<te_TRACK>>$85 TRACK

Go to track specified by the operand.  This command is used to nest
tracks to make a complex song.  Up to eight nested track calls can be
made per channel.  At full nesting any following TRACK commands will
be ignored.

The player routine will simply skip undefined tracks.

A "return from track" is automatically performed at the track end
code.


**** <<te_RPEAT>>$86 RPEAT and <<te_LOOP>>$87 LOOP

These two are used to create loops within tracks.  Up to eight nested
loops can be used per channel.

The loop is initiated by RPEAT command with the loop count as its
operand.  The loop starting point is the next line of the track from
which the player will keep playing until LOOP command is encountered.
LOOP will decrease the loop counter by one and jump back to the loop
starting point until the loop counter reaches zero.  The operand of
LOOP is ignored.


**** <<te_TRANSP>>$88 TRNSP

This is used to set the transposition byte of the channel.  It's a
signed value, so anything from $80 to $ff is considered a two's
complement, ie. $ff = -1, $fe = -2, etc.

The transposition is defined in semitones.


** Important DO NOTs:

- Do not set the time signature to 1/128 ($07).  The editor will
  freeze if you do so and there are any notes on the following lines.

- Do no use the "halftone up" command ('=') to set notes beyond B-9.
  You'll eventually reach the end code after 'F-;' and the editor will
  freeze if the track is playing while editing.


* Instrument Editor

|------------+--------------------------------------------------------------|
| ~1~ .. ~4~ | Edit [[ie_mg][MG parameters]]                                           |
| ~e~        | Edit volume [[ie_env][envelope parameters]]                              |
| ~f~        | Test note selection                                          |
| ~o~        | Octave bank                                                  |
| ~p~        | Play test note                                               |
| ~s~        | Edit [[ie_snd][sound parameters]]                                        |
| ~v~        | View output wave (useful to check BShift/DShift modulation)  |
| ~w~        | Go to wave editor                                            |
| ~<~        | Replace current instrument with data from another instrument |
|------------+--------------------------------------------------------------|


** <<ie_snd>>SND

This section specifies the following parameters:


*** a:Mo - sound mode

The sound mode can be one of the following:

|-----+-------+-------------------------------------------------------|
| $00 | <std> | standard (a.k.a. normal or plain sample) mode, looped |
| $01 | <bsm> | base shift mode                                       |
| $02 | <dyn> | dynamic mode                                          |
| $03 | <???> | single-shot std mode                                  |
|-----+-------+-------------------------------------------------------|

Any other value for this parameter defaults to single-shot std mode.

Caveat: In single-shot mode the previous sample must end before
another one will play on the same channel!  This is something to keep
in mind when making drum tracks, ie. keep your drum samples short or
end longer ones with a rest and fast volume envelope release.


**** <std> and <???>

This is the simplest sample player mode and will play samples as is.
The <???> is the single-shot variant of standard mode and is suitable
for drum and effect samples.


**** <bsm>

This is the "base shift mode".  The base shift mode uses an offsetting
method to select a "window" of a wave to be played.  This window can
be shifted on the fly with a [[ie_mg][MG]] to make a pulse-width modulation style
effect with an appropriately crafted wave.

Parameters specific to this mode are tagged with ~<bsm>~.


**** <dyn>

This is the "dynamic mode". The dynamic mode creates the final
waveform on the fly by mixing together two copies of the selected
wave.  These copies can be shifted in relation to each other and their
frequencies can be altered to create complex sounds.  The dynamic
nature of this mode allows seamless on-the-fly generation of higher
frequency waveforms for higher octaves without creating separate
waves.

Shifting and frequencies can be modulated with [[ie_mg][MG]]s.  Parameters
specific to this mode are tagged with ~<dyn>~.


*** b:Wa - wave

This sets the wave used by this instrument.  For standard and base
shifted modes a wave table of eight can be set up for higher octaves.


*** c:Bs - Base shift ~<bsm>~

This value offsets the waveform from its starting point.  For this to
create audible sound difference, an appropriately crafted wave is
required.


*** d:Ds - Dynamic shift ~<dyn>~

This value offsets the first copy of the waveform that the other copy
is mixed on top of.


*** e:Tr - transpose

The transpose parameter is entered as an unsigned byte and evaluated
as a signed byte, ie. $ff = -1, $fe = -2, etc.


*** f:Fq - Dynamic frequency ~<dyn>~

This parameter is only functional in sound mode 02.  Each of the
nybbles (individual hexadeciaml digits) represent a frequency
multiplier from ~$1~ to ~$10~ for the two waves to be mixed.  A ~$0~
is interpreted as ~$10~.

The base value to start with is ~$11~ instead of ~$00~.

The left number is for the "DShifted" first copy and the right value
is for the non-DShifted second copy mixed on top the first copy.

Tip: Editing this parameter is easiest to do with the numpad, 7 and 9
to edit the left nybble, and 1 and 3 to edit the right nybble.


** <<ie_env>>ENV - Envelope Generator

This section specifies the envelope generator parameters.

When editing these parameters, the generated "slopes" are shown in the
parameter window next to the waveform.  The slope values represent the
amount of change made at each player tick.

Internally the envelope generator is 16-bit. The most significant six
bits of the final calculated value after ADSR and MG calculations is
used to address a volume value from the volume table.


*** a:Tr - (unused?)

This parameter appears not to be used.


*** b:At - Attack time

This parameter specifies the attack time from start of note to Peak
level.  This value together with Peak level is used to calculate
ASlope (Attack Slope), which is the value used by the player
internally.

Attack time of $ff represents infinity and will make the instrument
silent.


*** c:Tl - Peak level (Top level)

This parameter specifies the Peak level between attack and decay.
Once this level is reached, the EG switches from attack to decay.


*** d:Dt - Decay time

This parameter specifies the decay time from Peak level to Sustain
level.  This value together with Peak and Sustain levels is used to
calculate DSlope (Decay Slope), which is the value used by the player
internally.

Decay time of $ff represents infinity, which means that the peak level
will also be the sustain level.


*** e:Sl - Sustain level

This parameter specifies the Sustain level.  The note volume will
decay to and stay at this level until note-off (rest, ~----~).


*** f:Rt - Release Time

This parameter specifies the time it takes from note-off to silence.
This value together with Sustain Level is used to calculate RSlope
(Release Slope), which is the value used by the player internally.

Release time of $ff represents infinity, ie. the sound will never
stop, even after a note-off, until a new note is played or the player
routine is stopped.


** <<ie_mg>>MG - Modulation Generator

Each instrument features four identical modulation generators.
Depending on the [[ie_mgBl][Block wave]] flag the oscillator generates a
triangle/saw or a square wave with time constants S1 and S2.

Similarly to the volume Envelope Generator, modulation speed is
relative to song speed (ie. score tempo).


*** a:De - Destination

The modulation destination is a hexadecimal number between $00 and
$07.  Any numbers past $07 are interpreted as $07.


**** $00 : off

The replayer will bypass any MG that is set off.  The other parameters
will not be processed at all.


**** $01 : FM - Frequency Modulation

Frequency modulation modulates the playback frequency of the sound,
just like it says on the tin.  This produces a vibrato effect.

This modulation results in a signed 8-bit value and affects the
playback period directly.


**** $02 : AM - Amplitude Modulation

This is the same for the amplitude, or volume of the sound, ie. a
tremolo effect.

Amplitude modulation is applied to the 16-bit internal amplitude value
after ADSR.


**** $03 : BShift - Base shift modulation ~<bsm>~

This modulates the base shift of the instrument.  With a specially
crafted waveform this can be used to create eg. a pulse-width
modulated square wave sound.

This modulation is internally 8-bit.


**** $04 : DShift - Dynamic shift modulation ~<dyn>~

This modulates the dynamic shift of the instrument.

This modulation is internally 8-bit.


**** $05 / $06 : FM+ / FM- - Frequency Modulation (period up = frequency down) / (period down = frequency up)

Unlike the ordinary FM mode ($01), these frequency modulation modes
modulate the frequency either up or down from the note frequency.

These modulations are internally 11-bit and affect the playback period
directly.


**** $07 : DynFreq - Dynamic frequency modulation ~<dyn>~

This modulates the waveform frequencies of a dynamic instrument.  Do
keep in mind that the modulation affects the whole byte, not just for
one or the other nybble.  However, with careful crafting of slope
values it may be possible to make fine changes to both nybbles in a
predictable manner.

This modulation is internally 8-bit.


*** <<ie_mgBl>>b:Bl - Block wave (boolean, $00 = off)

Setting this non-zero will cause the replayer to use the S1 and S2
parameters as time constants to make a square wave modulation instead
of the default triangle/saw wave.


*** c:Tr - Trigger mode (boolean, $00 = trigger at every note-on)

When trigger mode is set non-zero, the MG is not retriggered as long
as a note is being played.  This is useful to create a slowly changing
modulation over several notes.


*** d:Ss - Single-shot (boolean, $00 = off)

When single-shot mode is enabled, the MG will run only once and stop.


*** e:Sg - (unused)

This parameter appears not to be used.


*** f:Rv - Reverse (boolean, $00 = off)

Reverses the modulation operation, ie. modulating up becomes
modulating down and vice versa.


*** g:Dt - Delay time

This parameter specifies the time from trigger to start of modulation.
Time is specified in player ticks.


*** h:Lv - Level

This parameter specifies the amplitude, or level of modulation.
Internally the modulation level is a 16-bit value, of which the user
input is the most significant byte.


*** i:S1 / j:S2 - Slope 1 / Slope 2

These two slope time parameters are used to shape the modulation
waveform.


*** k:Hs / l:Qs - Half-shift / Quarter-shift

These values are used to shift the starting point of modulation
waveform depending on the channel the instrument plays on.  They're
mostly useful to desync modulators of an instrument playing on two
channels at the same time.

The Half-shift sets the initial modulation value to the Modulation
level.  The Quarter-shift sets the initial modulation value to half
the Modulation level.

|-------+-----------------------------------------------------------------|
| value | description                                                     |
|-------+-----------------------------------------------------------------|
| $00   | off                                                             |
|-------+-----------------------------------------------------------------|
| $01   | ~sch_FlagLR~ - shift is applied if the instrument plays on the  |
|       | right channel, ie. on channel 2 or 3.                           |
|-------+-----------------------------------------------------------------|
| $02   | ~sch_FlagLH~ - shift is applied if the instrument plays on the  |
|       | "higher" channel, ie. on channel 2 or 4.                        |
|-------+-----------------------------------------------------------------|
| > $02 | Undefined behaviour.  Non-zero values are used to address Sound |
|       | Channel structure directly.                                     |
|-------+-----------------------------------------------------------------|

Quarter-shift takes the higher priority if both are set.
      
Quarter-shift is always enabled for frequency modulation (destination
$01) when a delay time is set.


* Wave Editor

The Medley Sound Wave Editor is a simple yet powerful tool to make
short waveforms for use with Base Shift and Dynamic modes.  There are
four waveform displays on top: current sample buffer (Source A),
Source B, Result, and Undo Buffer.  Source B can be used to copy
sample data to other waves/samples.

Below each waveform is a parameter display, for example for a freshly
loaded preset sine wave it is ~80, 80 s1 x1~ while a sample merged
from an external source might have something like ~23f0, 0 s0 x0~.

1. The first hexadecimal number is the data buffer length.

2. The second value is currently known as "dummy".  A known use for it
   hasn't been discovered, yet.

3. The letter after the two described above shows if the sample is
   single- (s) or double-buffered (d).

4. The number after the buffer mode flag is the octave.  This value
   should be between 0 and 7.  Any other values for octaves will
   provide unpredictable results as the player routine will address
   memory outside the actual octave multiplier table.

5. The last one is the "FragFactor" which is not used.

|--------------+-------------------------------------------|
| ~/~          | Swap sources A and B                      |
| ~,~ (comma)  | Copy Result to Source A                   |
| ~.~ (period) | Copy Source A to Source B                 |
| ~u~          | Copy Undo buffer to Source A, "undo"      |
| ~k~          | Copy Source A to Undo Buffer, "kill"      |
| ~r~          | Rename wave                               |
| ~c~          | Change wave ie. choose another wave       |
| ~N~          | Allocate a new wave (into an unused slot) |
| ~S~          | Set wave buffer "single"                  |
| ~D~          | Set wave buffer "double"                  |
| ~o~          | Perform [[we_ops][operations]]                        |
| ~p~          | Generate a [[we_preset][preset]] waveform                |
|--------------+-------------------------------------------|


** Frags

These operations are not implemented.


** <<we_ops>>Operations

These mathematical operations allow editing and mixing of sample data
to create complex waveforms from simple waveforms generated with the
[[we_preset][Preset]] function.

*** a:SX – shift source A left in samples

This operation offsets the Source A waveform in a way that makes it
appear to move left in the visual preview.


*** b:SY – shift source A down (add a fixed value to each sample)

This operation adds a signed byte value to each sample of Source A,
which makes the waveform move down in the visual preview.


*** c:AM – amplitude (10 = no change)

This operation adjusts the amplitude of the Result waveform after
mixing.  The default is $10 and doesn't affect the aplitude, $08 is
half the amplitude and $20 is twice the amplitude.


*** d:FQ – frequency of source A (10 = no change)

This operation shrinks or expands the wave data of Source A to alter
its playback frequency.  It will not affect the mixed in Source B.


*** e:MX – mix sources (00 = A; ff = B; 80 will mix 50/50)

This operation mixes sources A and B.  Value of $00 will bypass the
mixing and use only Source A.  Value of $ff will use only Source B and
$80 will mix both evenly together.

The thing to keep in mind is that the Source B will not be looped if
it is shorter than the Result buffer!


*** f:RE - Adjust Result buffer length

This operation adjusts the Result buffer length.  This value defaults
to $10 which matches the length of Source A.  $08 will mean half the
length of Source A and $20 is double the length.

Do keep in mind that the octave number is calculated from the length
of the waveform data.  If you lengthen the waveform beyond 0x17e, or
382 bytes to make the octave go negative, it will no longer play back
right outside the wave editor.  This will also affect modifying longer
samples imported from external sources!


*** g:UF

This operation is not implemented.


*** h:PE – playback period (higher value = lower frequency)

This affects only the playback period of the previewed Result buffer,
not the buffer itself.


** <<we_preset>>Preset - generate waveforms

This operation is used to generate waveforms.  The operation will
replace any waveform data in Source A.


*** a:RA - generate a saw/triangle wave

The operand is used to adjust the duty cycle of the triangle wave.
$80 is pure triangle.


*** b:PU - generate a pulse/square wave

The operand is used to adjust the duty cycle of the square wave.  $80
equals 50%.


*** s - precalculated sine wave

Press ~s~ to copy the precalculated sine wave to Source A.


* File Menu

** (l)oad, (m)erge, and (i)mport

Medley Sound editor is able to load its own project format PVMS as
well as SMUS/IFF song data. The third supported format is raw sample
data encapsulated in a =HUNK_UNIT= file.

*Warning!* Loading will destroy your current project, even if you're
loading just a sample!  Use Merge or Import to load a sample into your
existing project!

The difference between Merge and Import is that Merge will silently
merge a complete PVMS project into the current one.  Import will query
what content is to be imported.


** (s)ave

This function saves the current project into a PVMS file.  The editor
is not directly able to save to Medley Sound Object (MSOB) format.


** <a>ssembly

This function is used to export the current project in memory into an
assembly source code which can be assembled into a Medley Sound
Object, and then linked into an executable.

The option menu is navigated with numpad arrow keys and options can be
changed by pressing return.  To produce the smallest possible MSOB,
set options to strip names and partial tables.

Asm68k available on Aminet has been tested to produce an object
readable by the standalone Medley Sound Player msplay, even if it
complains about a comment as two undefined identifiers, "future" and
"expansion".

Keep in mind that the implementation of UDATA is broken in msplay!


** (C)lear

This functions frees all allocated working memory.


* msed patches

In addition to missing features msed does have plenty of bugs in it.
This section describes patches to fix functionality that may corrupt
memory.

In the following sections you'll see quote blocks like this

: xxyy : 00 11 22 33

in which ~xxyy~ is the offset from the start of the ~msed~ executable.
The following hexadecimal numbers indicate the content starting from
the specified offset.  The modifications can be done with a hex editor.


** Track editor: semitone up

The upper boundary of "semitone up" is too high and allows turning a
note into a track end marker.

Replace

: 4a48 : 0c 10 00 7f        cmpi.b  #0x7f,(A0)

with

: 4a48 : 0c 10 00 7e        cmpi.b  #0x7e,(A0)

The above fix will change the check to compare against the penultimate
possible note value instead of the last one.  The following
conditional branch instruction (bhi) will skip the next addition
instruction only if the byte value (note or SCODE) at A0 is higher.


** Supervisor: optimise scores

The score optimiser has a bug which may cause the score table scan to
end prematurely.

To make sure the whole score table is scanned, replace

: 6ade : 70 00              moveq      #0x0,D0

with 

: 6ade : 74 00              moveq      #0x0,D2

The patch above initialises the register D2 used as a counter instead
of the scratch buffer register D0.  The pointers loaded to D0 will
replace all the bits in each case, which means that initial clearing
of the register isn't required.
