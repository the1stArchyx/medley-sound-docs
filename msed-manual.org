#+TITLE: Medley Sound editor V1.0 manual
#+SUBTITLE: a product of trial and error, and lots of reverse enginerding
#+AUTHOR: Lauri "Archyx" Lindholm
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper]


* Medley Sound editor V1.0 manual

Medley Sound is the software that was used to make the background
music for the Imploder 4.0.  The two songs used in it were called
"Plodemusic" and "requester deun", the first one being the main theme
tune and latter was the tune that played after the file implosion was
done and the save requester was shown.  The Meter Test feature in the
score editor was for fine tuning the meters in Imploder 4.0 to wiggle
with the theme tune.

This manual is a creation based on a lot of experimentation and a lot
more reverse engineering of the Medley Sound player routine and the
editor.  All of this was written because the original complete source
code and whatever documentation there had been was partially lost
prior to Paul releasing what little was left of this historical
software.

The editor doesn't have a very polished interface and plenty of the
values for various parameters just have to be known.  This manual is
an attempt to document these various parameters and their functional
values to make the editor useful once again.


** Some common commands and data input schemes

The different parts of the editor share certain common commands and
data input schemes.  The typical commands are as follows:

|-------------+------------------------------------------------|
| ~c~         | Change (or select) instrument/score/track/wave |
| ~r~         | Rename instrument/score/track/wave             |
| Shift + ~K~ | Delete ("kill")                                |
| Shift + ~N~ | Allocate new                                   |
| <SPC>       | Notes off / stop                               |
| <ESC>       | Cancel input/operation, exit editor            |
| Ctrl + ~L~  | Switch hardware low-pass filter on/off ("LED") |
| Ctrl + ~V~  | Open supervisor console                        |
|-------------+------------------------------------------------|

Not all of these commands work in every editor, but most do.

One thing to keep in mind is that the editor is designed to be used
with the default ~us~ keymap.


*** Number entry

A typical single-byte number entry uses the typewriter keyboard to
input individual hexadecimal numbers.  The current number in the
single digit position is pushed into tens and the number in tens is
discarded.  The ~1~ to ~9~ on the numpad are used in a special way to
modify the existing hex number:

+-----+-----+-----+-----+
|  [  |  ]  |  /  |  *  |
+-----+-----+-----+-----+
| -10 | $ff | +10 |  -  |
+-----+-----+-----+-----+
|  -4 | $80 |  +4 |  +  |
+-----+-----+-----+-----+
|  -1 | $00 |  +1 |  E  |
+-----+-----+-----+  n  |
|    0      |  .  |  t  |
+-----------+-----+-----+


** Supervisor

The editor features a "Supervisor" console from which certain
statistics can be viewed.  It also features optimising tools to delete
unused tracks, instruments, and waves to reduce memory footprint.

However, at least some of these optimising tools have logic flaws
which render the tools useless in their current implementation and may
cause deletion of all tracks/instruments/waves instead of just the
unused ones.

The score optimiser can potentially corrupt memory in addition to
plain clearing the score table without freeing the allocated memory.


*** ~i~ – info

Shows basic information about the current song in memory.


*** ~l~ – list

This command is used to list allocated instruments, scores, tracks, or
waves in the Supervisor console.  ~l~ alone does nothing.  See table
below.

|------+----------------------|
| ~li~ | List instruments     |
| ~ls~ | List scores          |
| ~lt~ | List tracks          |
| ~lw~ | List waves (samples) |
|------+----------------------|


*** ~m~ and ~v~ – monitor and view

Monitor and View are basically the same thing. The difference is that
View displays a single frame of player status while Monitor refreshes
the status display continuously.

: Enable ff   Flang Algo 03  Flang Speed 06  Volume 3f
:
: 0:on   C..3  02  ins 09 dbass2           Vol 3f
: 1:on   C..2  2b  ins 06 Carrilon         Vol 3f
: 2:on   C..3  42  ins 09 dbass2           Vol 31
: 3:on   E..2  06  ins 09 Snaredrum        Vol 3f

The first line shows player interrupt status, flanger algorithm and
speed, and the song volume.

The data shown for each channel is channel status (~on~ or ~off~), the
note, the play time of the note left, the instrument number and name,
and volume.


*** ~o~ – optimise

These commmands are used to clean up unused song parts before
exporting the song into assembly source.

Since these functions can be very unreliable, it's preferred to use an
external tool to convert a PVMS project selectively into an MSOB.
This document contains all the information needed to create such a
tool.


**** ~os~ – Optimise scores

**Do not use!** This feature is broken!  Initially it looked like it
might write to undefined memory, but it still uses an uninitialised
counter.  The executable should be patched first for this function to
operate correctly.

The intention of score optimisation is to move all allocated scores
one after another into a contiguous list.  Due to a bug that
initialises an incorrect register instead of the one used for the
counter, this function might not scan through the whole score table.


**** ~oa~ - Optimise all

Performs the following optimisations in order:

1. Optimise tracks.
2. Optimise instruments.
3. Optimise waves.


**** ~ot~ - Optimise tracks

Scans through all tracks used in scores and any tracks used by tracks
used in scores and deletes all the tracks not referenced to.


**** ~oi~ – Optimise instruments

Scans through all scores and tracks for any used instruments and
deletes any instruments not used.


**** ~ow~ – Optimise waves

Scans through all instruments and deletes all unused waves.


* Main Menu

** (m) Medley Editor

The Medley Editor is not implemented.


** (s) Score Editor

The Score Editor is used to define the four tracks and other
parameters that make each of 255 possible songs, $1..$ff.


** (t) Track Editor

The Track Editor is used to create and edit tracks, the maximum number
of them being 255, $1..$ff.  Tracks are pieces of single channel note
and control data and run independently from each other.  Proper timing
of tracks between channels is solely left to the song programmer,
which allows great flexibility to reuse tracks efficiently.


** (i) Instrument Editor

The Instrument Editor is used to define instrument parameters.  There
can be a maximum number of 255 instruments, $1..$ff, each using 1 to 8
waves defined by an octave table, a single volume envelope generator,
and four modulation generators.  Three operating modes are available
to produce sounds from plain samples to complex dynamic synthesis.


** (w) Wave Editor

The Wave Editor is also known as the Sample Editor.  The Wave Editor
has facilities to generate pulse and trinagle/saw waves, or a
precalculated sine wave, and an operation mode to edit and mix waves
together.


** (c) Chord Editor

The Chord Editor is not implemented.  It could be speculated that the
intention was to create an arpeggiator similar to the Future Player
implementation.


** (f) File Menu

The File Menu offers the usual project loading and saving as well as a
special option to export the song as an assembly language source code.
Assembling the source will produce a Medley Sound Object, or MSOB, for
use with the standalone player.


** (Q) Quit

To quit Medley Sound Editor you must press ~Shift + Q~.  If you press
just ~q~, the editor will show "Say what?" on the window title.
Pressing ~Esc~ will instruct "Shift-Q to Quit" in the window title.


* Score Editor

The Score Editor defines the starting tracks of the song played on the
four channels.  See Track Editor and the TRACK command to figure out
how to nest tracks to make a song out of multiple tracks.

A starting track, a default instrument, FxBase, FxRnd, and channel
volume are defined for each channel.  FxBase and FxRnd are discussed
further in a following section.  The channel volume appears to be a
non-functional variable.

*Note!* If you have song repeat enabled, the player routine will
become stuck in an endless loop if a starting track on any channel
contains no notes or only zero-length notes.  This will freeze the
whole computer!

Setting volumes and other score variables is typically not boundary
checked, which means the song programmer needs to take care that the
variables are within functional limits, eg. volumes are between 0 and
$3f.


** Keyboard commands

|-------------+------------------------------------------------------------------|
| <space>     | Stop playing                                                     |
| ~1~ .. ~4~  | Select channel                                                   |
| ~=~         | Fast forward ("Advance")                                         |
| ~a~         | Set Fl. Algo ([[se_flalgo][flanger algorithm]], $01..$05, or $00 = off)         |
| ~b~         | Set FxBase, see [[se_fx][Sound effects]]                                    |
| ~c~         | Change score                                                     |
| ~d~         | Set default instrument (Def. Ins)                                |
| Shift + ~D~ | Go to Instrument Editor, edit default instrument                 |
| ~h~         | Set Tempo Hi                                                     |
| ~i~         | Set instrument (on selected channel)                             |
| Shift + ~I~ | Go to Instrument Editor, edit instrument set on selected channel |
| Shift + ~K~ | Delete score                                                     |
| ~l~         | Set Tempo Lo                                                     |
| ~m~         | Meter test                                                       |
| ~n~         | Set FxRnd, see [[se_fx][Sound effects]]                                     |
| Shift + ~N~ | Allocate new score                                               |
| ~o~         | Set Transpose                                                    |
| ~p~         | Play song                                                        |
| Shift + ~P~ | Play From:                                                       |
| ~r~         | Rename score                                                     |
| Shift + ~R~ | Set song repeat (boolean, $00 = off, $ff = on)                   |
| ~s~         | Set Fl. Speed                                                    |
| ~t~         | Set track on selected channel                                    |
| Shift + ~T~ | Go to Track Editor, edit track set on selected channel           |
| ~u~         | Set Upd Reduc                                                    |
| Shift + ~U~ | Unchord (useful mainly with tracks imported from SMUS files)     |
| ~v~         | Set channel volume (Not implemented in the player!)              |
| Shift + ~V~ | Set song volume                                                  |
| Shift + ~X~ | Exchange tracks with secondary track set                         |
|-------------+------------------------------------------------------------------|

Notes:

- Secondary tracks are not used by the player.  (Or it's something for
  the "Medley" feature that was never implemented.)

- The Meter Test shows a mockup of Imploder 4.0 meters on top of the
  score editor.  The drum instrument numbers are hardcoded against
  preset meter deflections.  Other meter modes calculate deflection
  dynamically from a combination of note and note duration.


** Flanger

The flanger effect is implemented as changing channel detunes.  To
enable the flanger effect the Flang Speed and Flang Algorithm must be
set non-zero.  The Flang Speed is defined as an initial countdown
value, ie. higher values deliver a slower effect.

The flanger update is performed in the player interrupt code which
makes the Flang Speed definition be "update every nth interrupt
trigger", which also makes it relative to tempo.


*** <<se_flalgo>>Flanger algorithms

The five flanger algorithms are defined in the player routine as
follows:

|------+------+------+------+------|
| alg# | ch 0 | ch 1 | ch 2 | ch 3 |
|------+------+------+------+------|
|    1 |   +1 |   +1 |   ±0 |   ±0 |
|      |   ±0 |   ±0 |   +1 |   +1 |
|------+------+------+------+------|
|    2 |   ±0 |   +1 |   +2 |   -1 |
|      |   +1 |   ±0 |   -1 |   +2 |
|------+------+------+------+------|
|    3 |   ±0 |   +1 |   +2 |   -1 |
|      |   +1 |   +2 |   -1 |   ±0 |
|      |   +2 |   -1 |   ±0 |   +1 |
|      |   -1 |   ±0 |   +1 |   +2 |
|------+------+------+------+------|
|    4 |   ±0 |   ±0 |   -2 |   +2 |
|      |   +1 |   -1 |   -1 |   +1 |
|      |   +2 |   -2 |   ±0 |   ±0 |
|      |   +1 |   -1 |   -1 |   +1 |
|------+------+------+------+------|
|    5 |   -2 |   -1 |   ±0 |   +1 |
|      |   -1 |   ±0 |   +1 |   +2 |
|      |   ±0 |   +1 |   +2 |   -1 |
|      |   +1 |   +2 |   -1 |   -2 |
|------+------+------+------+------|

The algorithms are always defined as a multiple of four bytes, one for
each channel.  Setting the algorithm 0 or beyond 5 will disable the
effect.


** TODO <<se_fx>>Sound effects

Medley Sound was designed for game music and sound effects, so there
naturally is support for the sound effects in the music player.
FxBase ("effect time base") and FxRnd (channel stealing time
randomisation) are used to select sound channels for sound effects as
well as randomising the "channel stealing" and how long a channel is
kept "stolen".

This feature requires more research.  For plain music playing the Fx
parameters should be set to 0.


* Track Editor

** Keboard commands

*** Editing modes

|-------------+------------------------|
| Shift + ~D~ | Edit Duration          |
| Shift + ~E~ | Edit Tone and Duration |
| Shift + ~I~ | Insert Mode            |
| Shift + ~L~ | List Mode              |
| Shift + ~T~ | Edit Tone              |
|-------------+------------------------|

The set editing mode of a track persists for the track over track
changes and will also be saved into the project file.  Remember to
change a track back to *List Mode* when you're done editing to avoid
accidental edits!


*** Insert and edit mode functions

|------------------+--------------------------------------------------------|
| Return           | add line below (in insert mode)                        |
| Shift + Return   | insert line above (in insert mode)                     |
| ~a~ .. ~g~       | set note                                               |
| ~1~ .. ~9~       | set octave for note                                    |
| ~`~ (back-quote) | tie note (an asterisk shown before the note)           |
| ~!~              | [[te_TSIGN][TSIGN]] – set time signature (editor feature)            |
| ~@~              | [[te_DYNLV][DYNLV]] – set volume                                     |
| ~#~              | [[te_INSTR][INSTR]] – set instrument                                 |
| ~$~              | [[te_UDATA][UDATA]] – jump to a random track                         |
| ~%~              | [[te_TRACK][TRACK]] – "gosub" to a track                             |
| ~^~              | [[te_RPEAT][RPEAT]] – set start of a loop and loop count             |
| ~&~              | [[te_LOOP][LOOP]] – jump back to a loop start                       |
| ~*~              | [[te_TRANSP][TRANSP]] – transpose up or down in semitones             |
| ~+~              | ~++++~                                                 |
| ~_~ (underscore) | rest ~----~                                            |
| ~-~              | semitone down                                          |
| ~=  ('+')~       | semitone up (buggy sanity-check, don't go beyond B-9!) |
| ~t~              | Trace mode (see notes below)                           |
| Amiga + ~b~      | Set block                                              |
| Amiga + ~c~      | Copy block                                             |
| Amiga + ~i~      | Insert block                                           |
| Amiga + ~k~      | Kill line to buffer                                    |
| Amiga + ~l~      | Yank line from buffer                                  |
| Amiga + ~x~      | Cut block                                              |
| Home (numpad)    | Page up                                                |
| End (numpad)     | Page down                                              |
| Shift + Home     | Go to start of track                                   |
| Shift + End      | Go to end of track                                     |
|------------------+--------------------------------------------------------|

Track navigation is performed using the numpad instead of cursor keys.

Trace mode only works on tracks playing on channel one.  That means
you can't "trace" any other channel while playing a whole score.
Tracing is also rather choppy, so it doesn't work as a real-time
visual view like the pattern view of ProTracker.


** Note editing and SCODEs

Each line of a track represents a note and its length or a control
code (SCODE, most likely from Dutch "stuurcode") and its operand.


*** Notes ($00..$7f)

Notes are defined starting from ~C-1~ ($02 in track data) up to ~B-9~
($6d).  ~----~ ($00) is a rest that triggers ADSR release phase and
~++++~ ($01) is a non-implemented feature.

The operand for a note or a rest is its length, up to $7f.  Bit 7 of
the operand specifies a tied note, ie. inhibit retriggering of the
envelopes or modulation generator(s).  Tying notes together allows a
theoretical infinite note length.

When using the beat and bar signs of the track editor, note length of
$60 will match a whole note.  See [[te_TSIGN][TSIGN]] to adjust time signature.

| note      | length | dotted | triplet |
|-----------+--------+--------+---------|
| whole     | $60    |        |         |
| half      | $30    | $48    | $20     |
| quarter   | $18    | $24    | $10     |
| eighth    | $0c    | $12    | $08     |
| sixteenth | $06    | $09    | $04     |
| 1/32      | $03    |        | $02     |

Comparing to ProTracker patterns at VBlank speed 6, the timing is as
follows:

: ___PT___    ___ Medley Sound ___
: dec  hex    note length
:
:  00 = 00 == $00
:  01   01    $06   sixteenth
:  02   02    $0c   eighth
:  03   03    $12   dotted eighth
:  04 - 04 -- $18 - quarter
:  05   05    $1e
:  06   06    $24   dotted quarter
:  07   07    $2a
:  08 - 08 -- $30 - half
:  09   09    $36
:  10   0A    $3c
:  11   0B    $42
:  12 - 0C -- $48 - dotted half
:  13   0D    $4e
:  14   0E    $54
:  15   0F    $5a
:  16 = 10 == $60 = whole
:  17   11    $66
:  18   12    $6c
:  19   13    $72
:  20 - 14 -- $78
:  21   15    $7e


*** SCODEs ($80..$8f)

The control commands are internally known as SCODEs.  The existing
implementation of the player has a jump table for control codes from
$80 to $8f.  Setting a control code beyond $8f will cause the player
routine to jump to an undefined memory location.


**** $80 [end]

The unmodifyable SCODE is $80 and it's strictly reserved to end a
track.  The operand (always $00) is discarded by the player.

Track nesting table is checked at the track end and replay is resumed
from the calling track, if any.  If there is no track to return to,
song repeat flag is checked and if true, the track restarts.


**** <<te_TSIGN>>$81 TSIGN

This SCODE is ignored by the player.  It exists solely to make the
beat and bar indicators in the track editor functional.  The beat/bar
indicators don't handle TRACK commands which may break the beat count
when other tracks are called within the track.

The operand is 5+3 bit designation for the time signature.  The lower
three bits designate the length of the beat and the upper five bits
the count.  See table below.

+-----+-------+---+------+-----+
| $00 | x/1   |   | $00  | 1/x |
| $01 | x/2   |   | $08  | 2/x |
| $02 | x/4   |   | $10  | 3/x |
| $03 | x/8   |   | $18  | 4/x |
| $04 | x/16  |   | $20  | 5/x |
| $05 | x/32  |   | $28  | 6/x |
| $06 | x/64  |   | $30  | 7/x |
| $07 | x/128 |   | etc. |     |
+-----+-------+---+------+-----+

To set up the time signature 4/4, you'd take $18 from the right side
and add $02 from the left side, $18 + $02 = $1a.

For 6/8 the numbers would be $28 + $03 = $2b.

**Note!** 1/128 ($07) is known to crash the editor!


**** <<te_DYNLV>>$82 DYNLV

This sets the channel volume ("dynamic level").  The operand is
specified between $00 and $7f.  The replay routine will divide this by
two (with logical bitwise shift to right) and discard the least
significant bit.


**** <<te_INSTR>>$83 INSTR

Set instrument on current track. This should be rather
self-explanatory.


**** <<te_UDATA>>$84 UDATA

Note!  The implementation of UDATA is broken in the standalone Medley
Sound Player (msplay)!  Msplay's UDATA handler performs address
displacement calculation incorrectly and jumps to an arbitrary
location in track data.

The name of this SCODE isn't very clear regarding its function.  This
one is used to pick a random track from a specified number of
following TRACK lines.  Use of this SCODE must be carefully considered
because the replay routine doesn't sanity check the following track
data and the editor doesn't prevent entering non-functional data.

The operand should be a power of two, ie. $02, $04, $08, $10, $20,
$40, or $80.  Using any other value is not of use due to how the SCODE
handler is written.

This is how to use UDATA:

|------+-----------------+----------------------------|
| data | in track editor | description                |
|------+-----------------+----------------------------|
| 8404 | UDATA  04       | line count following UDATA |
| 8511 | TRACK  11       | first line                 |
| 8512 | TRACK  12       | second line                |
| 8513 | TRACK  13       | third line                 |
| 8514 | TRACK  14       | fourth line                |
|------+-----------------+----------------------------|

UDATA doesn't affect track nesting the way ordinary use of TRACK does.
This is because the actual SCODE of the lines following UDATA is
ignored, only the operand is used, and when valid the player continues
from the selected track without modification to the nesting tables.

This also means that any lines beyond will be ignored unless an
undefined track is specified.  In case of an undefined track, UDATA
returns as if the operand was $00 and the player continues processing
the following lines in order.

Using UDATA within RPEAT/LOOP can also provide unexpected behaviour as
LOOP will return to playing from the track where the RPEAT originally
was!  However, with careful design this feature can also be used to
create eg. drum tracks with pseudo-randomised fills at the ends.

Since Medley Sound no longer has Future Player's dedicated "jump to
track" command, UDATA can also be used to replace it by using UDATA
with operand $01:

|------+----------------------+-------------|
| data | track data in editor | description |
|------+----------------------+-------------|
| 8401 | UDATA  01            | jump to     |
| 8511 | TRACK  11            | track 11    |
|------+----------------------+-------------|


**** <<te_TRACK>>$85 TRACK

Go to track specified by the operand.  This command is used to nest
tracks to make a complex song.  Up to eight nested track calls can be
made per channel.  At full nesting any following TRACK commands will
be ignored.

The player routine will simply skip undefined tracks.

A "return from track" is automatically performed at the track end
code.


**** <<te_RPEAT>>$86 RPEAT and <<te_LOOP>>$87 LOOP

These two are used to create loops within tracks.  Up to eight nested
loops can be used per channel.

The loop is initiated by RPEAT command with the loop count as its
operand.  The loop starting point is the next line of the track from
which the player will keep playing until LOOP command is encountered.
LOOP will decrease the loop counter by one and jump back to the loop
starting point until the loop counter reaches zero.  The operand of
LOOP is ignored.


**** <<te_TRANSP>>$88 TRNSP

This is used to set the transposition byte of the channel.  It's a
signed value, so anything from $80 to $ff is considered a two's
complement, ie. $ff = -1, $fe = -2, etc.

The transposition is defined in semitones.


** Important DO NOTs:

- Do not set the time signature to 1/128 ($07).  The editor will
  freeze if you do so and there are any notes on the following lines.

- Do no use the "halftone up" command ('=') to set notes beyond B-9.
  You'll eventually reach the end code after 'F-;' and the editor will
  freeze if the track is playing while editing.


* Instrument Editor

|------------+--------------------------------------------------------------|
| ~1~ .. ~4~ | Edit [[ie_mg][MG parameters]]                                           |
| ~e~        | Edit volume [[ie_env][envelope parameters]]                              |
| ~f~        | Test note selection                                          |
| ~o~        | Octave bank                                                  |
| ~p~        | Play test note                                               |
| ~s~        | Edit [[ie_snd][sound parameters]]                                        |
| ~v~        | View output wave (useful to check BShift/DShift modulation)  |
| ~w~        | Go to wave editor                                            |
| ~<~        | Replace current instrument with data from another instrument |
|------------+--------------------------------------------------------------|


** <<ie_snd>>SND

This section specifies the following parameters:


*** a:Mo - sound mode

The sound mode can be one of the following:

|-----+-------+-------------------------------------------------------|
| $00 | <std> | standard (a.k.a. normal or plain sample) mode, looped |
| $01 | <bsm> | base shift mode                                       |
| $02 | <dyn> | dynamic mode                                          |
| $03 | <???> | single-shot std mode                                  |
|-----+-------+-------------------------------------------------------|

Any other value for this parameter defaults to single-shot std mode.

Caveat: In single-shot mode the previous sample must end before
another one will play on the same channel!  This is something to keep
in mind when making drum tracks, ie. keep your drum samples short or
end longer ones with a rest and fast volume envelope release.


**** <std> and <???>

This is the simplest sample player mode and will play samples as is.
The <???> is the single-shot variant of standard mode and is suitable
for drum and effect samples.


**** <bsm>

This is the "base shift mode".  The base shift mode uses an offsetting
method to select a "window" of a wave to be played.  This window can
be shifted on the fly with a [[ie_mg][MG]] to make a pulse-width modulation style
effect with an appropriately crafted wave.

Parameters specific to this mode are tagged with ~<bsm>~.


**** <dyn>

This is the "dynamic mode". The dynamic mode creates the final
waveform on the fly by mixing together two copies of the selected
wave.  These copies can be shifted in relation to each other and their
frequencies can be altered to create complex sounds.  The dynamic
nature of this mode allows seamless on-the-fly generation of higher
frequency waveforms for higher octaves without creating separate
waves.

Shifting and frequencies can be modulated with [[ie_mg][MG]]s.  Parameters
specific to this mode are tagged with ~<dyn>~.


*** b:Wa - wave

This sets the wave used by this instrument.  For standard and base
shifted modes a wave table of eight can be set up for higher octaves.


*** c:Bs - Base shift ~<bsm>~

This value offsets the waveform from its starting point.  For this to
create audible sound difference, an appropriately crafted wave is
required.


*** d:Ds - Dynamic shift ~<dyn>~

This value offsets the first copy of the waveform that the other copy
is mixed on top of.


*** e:Tr - transpose

The transpose parameter is entered as an unsigned byte and evaluated
as a signed byte, ie. $ff = -1, $fe = -2, etc.


*** f:Fq - Dynamic frequency ~<dyn>~

This parameter is only functional in sound mode 02.  Each of the
nybbles (individual hexadeciaml digits) represent a frequency
multiplier from ~$1~ to ~$10~ for the two waves to be mixed.  A ~$0~
is interpreted as ~$10~.

The base value to start with is ~$11~ instead of ~$00~.

The left number is for the "DShifted" first copy and the right value
is for the non-DShifted second copy mixed on top the first copy.

Tip: Editing this parameter is easiest to do with the numpad, 7 and 9
to edit the left nybble, and 1 and 3 to edit the right nybble.


** <<ie_env>>ENV - Envelope Generator

This section specifies the envelope generator parameters.

When editing these parameters, the generated "slopes" are shown in the
parameter window next to the waveform.  The slope values represent the
amount of change made at each player tick.

Internally the envelope generator is 16-bit. The most significant six
bits of the final calculated value after ADSR and MG calculations is
used to address a volume value from the volume table.


*** a:Tr - (unused?)

This parameter appears not to be used.


*** b:At - Attack time

This parameter specifies the attack time from start of note to Peak
level.  This value together with Peak level is used to calculate
ASlope (Attack Slope), which is the value used by the player
internally.

Attack time of $ff represents infinity and will make the instrument
silent.


*** c:Tl - Peak level (Top level)

This parameter specifies the Peak level between attack and decay.
Once this level is reached, the EG switches from attack to decay.


*** d:Dt - Decay time

This parameter specifies the decay time from Peak level to Sustain
level.  This value together with Peak and Sustain levels is used to
calculate DSlope (Decay Slope), which is the value used by the player
internally.

Decay time of $ff represents infinity, which means that the peak level
will also be the sustain level.


*** e:Sl - Sustain level

This parameter specifies the Sustain level.  The note volume will
decay to and stay at this level until note-off (rest, "----").


*** f:Rt - Release Time

This parameter specifies the time it takes from note-off to silence.
This value together with Sustain Level is used to calculate RSlope
(Release Slope), which is the value used by the player internally.

Release time of $ff represents infinity, ie. the sound will never
stop after a note-off.


** <<ie_mg>>MG - Modulation Generator

Each instrument features four identical modulation generators.
Depending on the [[ie_mgBl][Block wave]] flag the oscillator generates a
triangle/saw or a square wave with time constants S1 and S2.

Similarly to the volume Envelope Generator, modulation speed is
relative to song speed (ie. score tempo).


*** a:De - Destination

The modulation destination is a hexadecimal number between $00 and
$07.  Any numbers past $07 are interpreted as $07.


**** $00 : off

The replayer will bypass any MG that is set off.  The other parameters
will not be processed at all.


**** $01 : FM - Frequency Modulation

Frequency modulation modulates the playback frequency of the sound,
just like it says on the tin.  This produces a vibrato effect.

This modulation results in a signed 8-bit value and affects the
playback period directly.


**** $02 : AM - Amplitude Modulation

This is the same for the amplitude, or volume of the sound, ie. a
tremolo effect.

Amplitude modulation is applied to the 16-bit internal amplitude value
after ADSR.


**** $03 : BShift - Base shift modulation ~<bsm>~

This modulates the base shift of the instrument.  With a specially
crafted waveform this can be used to create eg. a pulse-width
modulated square wave sound.

This modulation is internally 8-bit.


**** $04 : DShift - Dynamic shift modulation ~<dyn>~

This modulates the dynamic shift of the instrument.

This modulation is internally 8-bit.


**** $05 / $06 : FM+ / FM- - Frequency Modulation (period up = frequency down) / (period down = frequency up)

Unlike the ordinary FM mode ($01), these frequency modulation modes
modulate the frequency either up or down from the note frequency.

These modulations are internally 11-bit and affect the playback period
directly.


**** $07 : DynFreq - Dynamic frequency modulation ~<dyn>~

This modulates the waveform frequencies of a dynamic instrument.  Do
keep in mind that the modulation affects the whole byte, not just for
one or the other nybble.  However, with careful crafting of slope
values it may be possible to make fine changes to both nybbles in a
predictable manner.

This modulation is internally 8-bit.


*** <<ie_mgBl>>b:Bl - Block wave (boolean, $00 = off)

Setting this non-zero will cause the replayer to use the S1 and S2
parameters as time constants to make a square wave modulation instead
of the default triangle/saw wave.


*** c:Tr - Trigger mode (boolean, $00 = trigger at every note-on)

When trigger mode is set non-zero, the MG is not retriggered as long
as a note is being played.  This is useful to create a slowly changing
modulation over several notes.


*** d:Ss - Single-shot (boolean, $00 = off)

When single-shot mode is enabled, the MG will run only once and stop.


*** e:Sg - (unused)

This parameter appears not to be used.


*** f:Rv - Reverse (boolean, $00 = off)

Reverses the modulation operation, ie. modulating up becomes
modulating down and vice versa.


*** g:Dt - Delay time

This parameter specifies the time from trigger to start of modulation.
Time is specified in player ticks.


*** h:Lv - Level

This parameter specifies the amplitude, or level of modulation.
Internally the modulation level is a 16-bit value, of which the user
input is the most significant byte.


*** i:S1 / j:S2 - Slope 1 / Slope 2

These two slope time parameters are used to shape the modulation
waveform.


*** k:Hs / l:Qs - Half-shift / Quarter-shift

These values are used to shift the starting point of modulation
waveform depending on the channel the instrument plays on.  They're
mostly useful to desync modulators of an instrument playing on two
channels at the same time.

The Half-shift sets the initial modulation value to the Modulation
level.  The Quarter-shift sets the initial modulation value to half
the Modulation level.

|-------+-----------------------------------------------------------------|
| value | description                                                     |
|-------+-----------------------------------------------------------------|
| $00   | off                                                             |
|-------+-----------------------------------------------------------------|
| $01   | ~sch_FlagLR~ - shift is applied if the instrument plays on the  |
|       | right channel, ie. on channel 2 or 3.                           |
|-------+-----------------------------------------------------------------|
| $02   | ~sch_FlagLH~ - shift is applied if the instrument plays on the  |
|       | "higher" channel, ie. on channel 2 or 4.                        |
|-------+-----------------------------------------------------------------|
| > $02 | Undefined behaviour.  Non-zero values are used to address Sound |
|       | Channel structure directly.                                     |
|-------+-----------------------------------------------------------------|

Quarter-shift takes the higher priority if both are set.
      
Quarter-shift is always enabled for frequency modulation (destination
$01) when a delay time is set.


* Wave Editor

The Medley Sound Wave Editor is a simple yet powerful tool to make
short waveforms for use with Base Shift and Dynamic modes.  There are
four waveform displays on top: current sample buffer (Source A),
Source B, Result, and Undo Buffer.  Source B can be used to copy
sample data to other waves/samples.

Below each waveform is a parameter display, for example for a freshly
loaded preset sine wave it is ~80, 80 s1 x1~ while a sample merged
from an external source might have something like ~23f0, 0 s0 x0~.

1. The first hexadecimal number is the data buffer length.

2. The second value is currently known as "dummy".  A known use for it
   hasn't been discovered, yet.

3. The letter after the two described above shows if the sample is
   single- (s) or double-buffered (d).

4. The number after the buffer mode flag is the octave.  This value
   should be between 0 and 7.  Any other values for octaves will
   provide unpredictable results as the player routine will address
   memory outside the actual octave multiplier table.

5. The last one is the "FragFactor" which is not used.

|--------------+-------------------------------------------|
| ~/~          | Swap sources A and B                      |
| ~,~ (comma)  | Copy Result to Source A                   |
| ~.~ (period) | Copy Source A to Source B                 |
| ~u~          | Copy Undo buffer to Source A, "undo"      |
| ~k~          | Copy Source A to Undo Buffer, "kill"      |
| ~r~          | Rename wave                               |
| ~c~          | Change wave ie. choose another wave       |
| ~N~          | Allocate a new wave (into an unused slot) |
| ~S~          | Set wave buffer "single"                  |
| ~D~          | Set wave buffer "double"                  |
| ~o~          | Perform [[we_ops][operations]]                        |
| ~p~          | Generate a [[we_preset][preset]] waveform                |
|--------------+-------------------------------------------|


** Frags

These operations are not implemented.


** <<we_ops>>Operations

These mathematical operations allow editing and mixing of sample data
to create complex waveforms from simple waveforms generated with the
[[we_preset][Preset]] function.

*** a:SX – shift source A left in samples

This operation offsets the Source A waveform in a way that makes it
appear to move left in the visual preview.


*** b:SY – shift source A down (add a fixed value to each sample)

This operation adds a signed byte value to each sample of Source A,
which makes the waveform move down in the visual preview.


*** c:AM – amplitude (10 = no change)

This operation adjusts the amplitude of the Result waveform after
mixing.  The default is $10 and doesn't affect the aplitude, $08 is
half the amplitude and $20 is twice the amplitude.


*** d:FQ – frequency of source A (10 = no change)

This operation shrinks or expands the wave data of Source A to alter
its playback frequency.  It will not affect the mixed in Source B.


*** e:MX – mix sources (00 = A; ff = B; 80 will mix 50/50)

This operation mixes sources A and B.  Value of $00 will bypass the
mixing and use only Source A.  Value of $ff will use only Source B and
$80 will mix both evenly together.

The thing to keep in mind is that the Source B will not be looped if
it is shorter than the Result buffer!


*** f:RE - Adjust Result buffer length

This operation adjusts the Result buffer length.  This value defaults
to $10 which matches the length of Source A.  $08 will mean half the
length of Source A and $20 is double the length.

Do keep in mind that the octave number is calculated from the length
of the waveform data.  If you lengthen the waveform beyond 0x17e, or
382 bytes to make the octave go negative, it will no longer play back
right outside the wave editor.  This will also affect modifying longer
samples imported from external sources!


*** g:UF

This operation is not implemented.


*** h:PE – playback period (higher value = lower frequency)

This affects only the playback period of the previewed Result buffer,
not the buffer itself.


** <<we_preset>>Preset - generate waveforms

This operation is used to generate waveforms.  The operation will
replace any waveform data in Source A.


*** a:RA - generate a saw/triangle wave

The operand is used to adjust the duty cycle of the triangle wave.
$80 is pure triangle.


*** b:PU - generate a pulse/square wave

The operand is used to adjust the duty cycle of the square wave.  $80
equals 50%.


*** s - precalculated sine wave

Press ~s~ to copy the precalculated sine wave to Source A.


* File Menu

** (l)oad, (m)erge, and (i)mport

Medley Sound editor is able to load its own project format "PVMS" as
well as SMUS/IFF song data. The third supported format is raw sample
data encapsulated in a HUNK_UNIT file.

*Warning!* Loading will destroy your current project, even if you're
loading just a sample!  Use Merge or Import to load a sample into your
existing project!

The difference between Merge and Import is that Merge will silently
merge a complete PVMS project into the current one.  Import will query
what content is to be imported.


** (s)ave

This function saves the current project into a PVMS file.  The editor
is not directly able to save to Medley Sound Object (MSOB) format.


** <a>ssembly

This function is used to export the current project in memory into an
assembly source code which can be assembled into a Medley Sound
Object, and then linked into an executable.

The option menu navigated with numpad arrow keys and options can be
changed by pressing return.  To produce the smallest possible MSOB,
set options to strip names and partial tables.

Asm68k available on Aminet has been tested to produce an object
readable by the standalone Medley Sound Player msplay, even if it
complains about a comment as two undefined identifiers, "future" and
"expansion".

Keep in mind that the implementation of UDATA is broken in msplay!


** (C)lear

This functions frees all working memory.


* File formats

** TODO PVMS

PVMS is the project file format of Medley Sound editor.  Medley Sound
player (msplay) does not read this format.


*** Basic file structure

|          offset | size                 | description             |
|-----------------+----------------------+-------------------------|
|             0x0 | .l                   | magic bytes : "PVMS"    |
|             0x4 | .b × ($file_len - 8) | one or more data chunks |
| ($file_len - 4) | .l                   | file end marker "END."  |


*** Basic data chunk structure

| offset | size    | description                                                                                 |
|--------+---------+---------------------------------------------------------------------------------------------|
|    0x0 | .l      | chunk ID : "INS:", "TRK:", "SCO:", or "WAV2"                                                |
|    0x4 | .w      | header_size = 0x007a, 0x0020, 0x0032, or 0x001c                                             |
|    0x6 | .b × ?? | data blocks                                                                                 |
|     ?? | .w      | index counter 0xffff = end of chunk (only the most significant bit is checked during load!) |


*** Basic data block structure

|               offset | size              | description                       |
|----------------------+-------------------+-----------------------------------|
|                  0x0 | .w                | index counter, starts from 0x0001 |
|                  0x2 | .b × $header_size | data/header                       |
| ($header_size + 0x2) | .b × $size_of     | wave/track data                   |


** TODO MSOB

MSOB is the export file format of Medley Sound, "Medley Sound OBject".
This is the format msplay loads and plays.


*** Header

| offset | size    | description                              |
|--------+---------+------------------------------------------|
|    0x0 | .l      | magic bytes : "MSOB"                     |
|    0x4 | .l      | displacement: score table                |
|    0x8 | .l      | displacement: track table                |
|    0xc | .l      | displacement: instrument table           |
|   0x10 | .l      | displacement: wave table                 |
|   0x14 | .l ×0x4 | reserved (0x00000000)                    |
|   0x24 | .b      | flag: names ($00 = stripped; $ff = kept) |
|   0x25 | .b      | flag: tables ($00 = full; $ff = partial) |
|   0x26 | .b ×0x2 | reserved (0x00)                          |


*** Tables

The score, track, instrument, and wave tables are displacement tables
to data entries.  Two formats of these tables exist depending on the
flag in the header at offset 0x25.

A full table (0x00 at 0x25) is always 0x100 longwords, or 1 kB long:

| offset | size     | description                                                  |
|--------+----------+--------------------------------------------------------------|
|    0x0 | .l       | always 0x00000000                                            |
|    0x4 | .l ×0xff | displacements to data entries, 0x00000000 = undefined/unused |


A partial table (0xff at 0x25) is preceded by the table length:

| offset | size            | description                                                              |
|--------+-----------------+--------------------------------------------------------------------------|
|   -0x2 | .w              | table length (byte, but stored as a word for 68k data alignment reasons) |
|    0x0 | .l              | always 0x00000000                                                        |
|   0x04 | .l x $table_len | displacements to data entries, 0x00000000 = undefined/unused             |


During playback the length of the tables is irrelevant as long as
there are no references to tracks/instruments/waves beyond the last
defined entries.

At the moment of writing this, the exact behaviour of msplay hasn't
been analysed, so for any new replayer implementations it is
recommended to reserve memory for full zeroed tables and adjust the
displacements accordingly or add additional checks to ignore
references beyond the defined data to avoid references to random
memory.


* msed internals

This section describes various internal data structures of the Medley
Sound editor.  It's useful only for those who intend to reverse
engineer and learn to understand how the editor works internally, or
maybe to even extend its functionality.  See [[* File formats][File formats]] if you only
need the file format descriptions.  These tables were created during
the reverse engineering and redocumenting of the editor and may be
partially inaccurate or incomplete.


** Memory map

This section describes the mapping of the memory block reserved during
startup of the program.  The base address of the memory block is kept
in register A5 during the execution of the program.  This memory is
only used for the user interface and editor function parts of the
program.

Dynamic memory allocation is done with the convention of reserving
four extra bytes to store the memory block size at the start of the
reserved block to free the correct amount of memory as the old
AllocMem()/FreeMem() doesn't keep track of memoryblock sizes reserved.
The only exception is the working memory size described below as it's
hard-coded into the program.

~mem_SizeOf~ = 0x2288

|--------+-------------------+------------------------------+--------+----------------------------------------------------------------------|
| offset | size              | name                         |   init | description                                                          |
|--------+-------------------+------------------------------+--------+----------------------------------------------------------------------|
|    0x0 | .l                |                              |        | * function pointer for exit subroutine                               |
|    0x4 | .l                | ~mem_IntuitionBase~          |        | * base address of intuition.library                                  |
|    0x8 | .l                | ~mem_GraphicsBase~           |        | * base address of graphics.library                                   |
|    0xc | .l                |                              |        |                                                                      |
|   0x10 | .l                |                              |        | * handle for output                                                  |
|   0x14 | .l                | ~mem_xPtrFormatString~       |        | * function pointer for xFormatString (initialised at program start)  |
|   0x18 | .l                | ~mem_dosCmdBuf~              |        | * dosCmdBuf                                                          |
|   0x1c | .l                | ~mem_dosCmdLen~              |        | dosCmdLen                                                            |
|   0x20 | .l                |                              |        | * handle for input                                                   |
|   0x24 | .l                |                              |        | { DOS argument stuff }                                               |
|   0x28 | .l                | ~mem_DosBase~                |        | * base address of dos.library                                        |
|   0x2c | .l                | ~mem_SPatInit2~              |        | stack pointer at end of main init                                    |
|--------+-------------------+------------------------------+--------+----------------------------------------------------------------------|
|   0x30 | .b                |                              |        | window title status                                                  |
|   0x32 | .l                | ~mem_SPatMainMenu~           |        | stack pointer at start of main menu                                  |
|   0x36 | .l                |                              |        | * window title                                                       |
|   0x3a | .w                | ~mem_weSelWaveNum~           |        | wave editor: selected wave number                                    |
|   0x3c | .l × 0x100        |                              |        | wave table (pointers to waves)                                       |
|  0x43c | .l × 0x100        |                              |        | track table (pointers to tracks)                                     |
|  0x83c | .l × 0x100        |                              |        | instrument table (pointers to instruments)                           |
|  0xc3c | .l                | ~mem_wePlayWavePtr~          |        | * wave editor: pointer to wave being player                          |
|  0xc40 | .l                | ~mem_SPatWaveEd~             |        | stack pointer at start of Wave Editor                                |
|  0xc44 | .l                |                              |        | * wave, sample editor buffer, Source A                               |
|  0xc48 | .b × 0x10         | ~mem_weOperations~           |        | wave editor [[mm_weops][operations]]                                               |
|  0xc54 | .l                |                              |        | * wave, sample editor buffer, Undo                                   |
|  0xc70 | .l                |                              |        | * wave, sample editor buffer, Result                                 |
|  0xc8c | .l                |                              |        | * wave, sample editor buffer, Source B                               |
|  0xca8 | .l                |                              |        | *                                                                    |
|  0xcac | .l                |                              |        | *                                                                    |
|  0xcb0 | .l                |                              |        | *                                                                    |
|  0xd14 | .l × 0xc8 (200)   |                              |        | string buffer (function 0x14)                                        |
|  0xddc | .l × 0x100        | ~mem_ScoTable~               |        | score table (pointers to scores)                                     |
|  0xde0 | .l                | ~mem_ScoTable1~              |        | score table, pointer to score #1                                     |
| 0x11dc | .w                |                              |        | scratch buffer (optimisation functions)                              |
| 0x11de | .w                |                              |        | scratch buffer (optimisation functions)                              |
| 0x11e0 | .l × 0x10         | ~mem_LabelBuffer~            |        | str                                                                  |
| 0x11f1 | .b                | ~mem_PrevPenCol~             |        | gfx: Previous pen colour                                             |
| 0x11f2 | .w                | ~mem_gfxCoordRoot1~          |   0x63 | gfx: Coordinate root                                                 |
| 0x11f4 | .w                | ~mem_gfxCoordRoot2~          |   0x1e | gfx: Coordinate root                                                 |
| 0x11f6 | .w                | ~mem_gfxCoordRoot3~          |   0xb4 | gfx: Coordinate root                                                 |
| 0x11f8 | .w                | ~mem_gfxCoordRoot4~          |  0x14a | gfx: Coordinate root                                                 |
| 0x11fa | .w                | ~mem_gfxCoordRoot5~          |  0x1e0 | gfx: Coordinate root                                                 |
| 0x11fc | .w                | ~mem_gfxCoordRoot6~          |   0x66 | gfx: Coordinate root                                                 |
| 0x11fe | .w                | ~mem_gfxCoordRoot7~          |   0x16 | gfx: Coordinate root                                                 |
| 0x1200 | .b                |                              |        | flag                                                                 |
| 0x1201 | .b                |                              |        | flag                                                                 |
| 0x1202 | .w                |                              |        |                                                                      |
| 0x1204 | .b × 0x4c         | ~mem_CurWinTitle~            |        | str, window title                                                    |
| 0x125e | .l                |                              |        | * interrupt pointer ?                                                |
| 0x1262 | .w                |                              |        |                                                                      |
| 0x1264 | .l                |                              |        | * memory                                                             |
| 0x1268 | .b                | ~mem_CurPenCol~              |        | gfx: Current pen colour                                              |
| 0x1269 | .b                |                              |        | SMUS import: track counter                                           |
| 0x126a | .w                |                              |        |                                                                      |
| 0x126c | .l                |                              |        | * handle of main window (Exec, Intuition)                            |
| 0x1270 | .l                |                              |        | * handle of main window (Graphics)                                   |
| 0x1272 |                   |                              |        |                                                                      |
| 0x1274 | .w                | ~mem_fmPVMSloaderHdrLen~     |        | PVMS loader, header length                                           |
| 0x1276 | .l                | ~mem_SMUStargetScore~        |        | * SMUS import: target score                                          |
| 0x127a | .b                | ~mem_ProjectModified~        |        | Flag: project modified                                               |
| 0x127b | .b                |                              |        | { SMUS track import, flag of some sort }                             |
| 0x127c | .w                |                              |        | file menu: PVMS section loader, index counter                        |
| 0x1280 | .b × 0x100        | ~mem_ScratchBuf1~            |        | scratch buffer, waves                                                |
| 0x1380 | .b × 0x100        | ~mem_ScratchBuf3~            |        | scratch buffer, tracks                                               |
| 0x1480 | .b × 0x100        | ~mem_ScratchBuf4~            |        | scratch buffer, scores                                               |
| 0x1580 | .b × 0x52         | ~mem_StringReqBuffer~        |        | string requester buffer                                              |
| 0x15d2 | .w                | ~mem_fmWaveCount~            |        | file menu: loaded sample/wave count                                  |
| 0x15d4 | .b × 0x100        | ~mem_ScratchBuf2~            |        | scratch buffer, instruments                                          |
| 0x16d4 | .b × 0x100        | ~mem_ScratchBuf5~            |        | scratch buffer                                                       |
|--------+-------------------+------------------------------+--------+----------------------------------------------------------------------|
| 0x17d4 | .b                | ~mem_SMUSDurOverflow~        |        | SMUS import: duration overflow flag                                  |
| 0x17d5 | .b                | ~mem_ProjectLoaded~          |        | Flag: project wipe req on quit/clear                                 |
| 0x17d6 | .b                | ~mem_ImportSkip~             |        | PVMS import: skip                                                    |
| 0x17d7 | .b                | ~mem_fmLoadImportMode~       |        | PVMS loader flag (set: import; clear: load, merge)                   |
| 0x17d8 | .w                |                              |        | file menu: loaded track count                                        |
| 0x17da | .w                |                              |        | file menu: loaded score count                                        |
| 0x17dc | .w                |                              |        | file menu: loaded instrument count                                   |
| 0x17de | .b                | ~mem_ImportESC~              |        | PVMS import: cancel                                                  |
| 0x17df | .b                | ~mem_ImportAll~              |        | PVMS import: all                                                     |
| 0x17e0 | .l                | ~mem_SPatFileMenu~           |        | * SP at File Menu entry                                              |
| 0x17e4 | .l                |                              |        | * string                                                             |
| 0x17e8 | .l                |                              |        |                                                                      |
| 0x17ec | .l                | ~mem_PtrStringReqBuffer~     |        | * string requester buffer, eg. filename                              |
| 0x17f0 | .l                |                              |        | * * function pointer                                                 |
| 0x17f4 | .l                | ~mem_FileMemBufPtr~          |        | * file memory buffe pointer                                          |
| 0x17f8 | .l                | ~mem_SMUSimportSrcLen~       |        | SMUS import: source length                                           |
| 0x17fc | .l                | ~mem_SMUSimportSrcEnd~       |        | SMUS import: source end                                              |
| 0x1800 | .b × ~sco_SizeOf~ | ~mem_teLocalScore~           |        | track editor: local score structure                                  |
| 0x1832 | .w                |                              |        | { relates to 0x184a }                                                |
| 0x1834 | .b                |                              |        | track editor: cursor position in edit window?                        |
| 0x1835 | .b                | ~mem_teInsertBelow~          |        | track editor: insert mode, set when line inserted below current line |
| 0x1836 | .w                |                              |        | track editor: cliboard buffer length                                 |
| 0x1838 | .w                |                              |        | track editor: linekill buffer                                        |
| 0x183a | .w                |                              |        |                                                                      |
| 0x183c | .w                |                              |        | { relates to 0x1858 }                                                |
| 0x183e | .w                |                              |        | track editor: trace mode view ?                                      |
| 0x1840 | .w                |                              |        | track editor:                                                        |
| 0x1842 | .l                |                              |        | * track editor: clipboard insert buffer                              |
| 0x1846 | .w                |                              |        | track editor: track data size in bytes                               |
| 0x1848 | .w                | ~mem_teLineScrapBuf~         |        | track editor: scrap buffer for single line inserts                   |
| 0x184a | .w                |                              |        |                                                                      |
| 0x184c | .l                | ~mem_SPatTrkEdit~            |        | * SP at Track Editor entry                                           |
| 0x1850 | .l                |                              |        | * track editor: selected track                                       |
| 0x1854 | .w                | ~mem_teSelTrkNum~            |        | track editor: selected track number                                  |
| 0x1855 | .b                | ~mem_teSelTrkNumL~           |        |                                                                      |
| 0x1858 | .w                |                              |        |                                                                      |
| 0x185a | .w                |                              |        |                                                                      |
| 0x185c | .b                |                              |        | track editor: editing mode                                           |
| 0x185d | .b                |                              |        | { instrument editor }                                                |
| 0x185e | .w                | ~mem_seChannelCounter~       |        | score editor: channel counter, channel column drawing                |
| 0x1860 | .b × 5            | ~mem_MeterBuffer~            |        | "Imploder meter buffer"                                              |
| 0x186a | .l                |                              |        | * "wave", "track", "score", "instrument"                             |
| 0x186e | .w                | ~mem_seChanColumn~           |        | score editor: x coordinate for channel column                        |
| 0x1870 |                   |                              |        |                                                                      |
| 0x1878 | .w                | ~mem_seSelChanColumn~        |        | score editor: x coordinate of selected channel column                |
| 0x187a | .w                |                              |        | score editor: selected score number                                  |
| 0x187c | .w                | ~mem_seCh1Column~            | 0x0008 | score editor: x coordinate, channel 1                                |
| 0x187e | .w                | ~mem_seCh2Column~            | 0x00ac | score editor: x coordinate, channel 2                                |
| 0x1880 | .w                | ~mem_seCh3Column~            | 0x0148 | score editor: x coordinate, channel 3                                |
| 0x1882 | .w                | ~mem_seCh4Column~            | 0x01e4 | score editor: x coordinate, channel 4                                |
| 0x1884 | .l                |                              |        | * SP stored at Score Editor entry                                    |
| 0x1888 | .l                | ~mem_ScoEdSelScore~          |        | * score editor: selected score                                       |
| 0x188c | .w                | ~mem_seSelectedChan~         |        | score editor: selected channel                                       |
| 0x188d | .b                | ~mem_seSelectedChanB~        |        | score editor: selected channel, lower byte                           |
| 0x188e | .l                |                              |        | * instrument editor: selected MG                                     |
| 0x1892 | .w                | ~mem_InstEdSelMgNum~         |        | instrument editor: selected MG number                                |
| 0x1894 | .l                |                              |        | * SP stored at Instrument Editor entry                               |
| 0x1898 | .l                |                              |        |                                                                      |
| 0x189c | .w                |                              |        |                                                                      |
| 0x189e | .l                | ~mem_InstEdSelInst~          |        | * instrument editor: selected instrument                             |
| 0x18a2 | .w                | ~mem_InstEdSelInstNum~       |        | instrument editor: selected instrument number                        |
| 0x18a4 | .w                | ~mem_ieColumn1~              | 0x001a | instrument editor: x coordinate, column 1                            |
| 0x18a6 | .w                | ~mem_ieColumn2~              | 0x005e | instrument editor: x coordinate, column 2                            |
| 0x18a8 |                   |                              |        | instrument editor: default instrument when none selected ?           |
| 0x18e8 | .w                | ~mem_ieColumn3~              | 0x0078 | instrument editor: x coordinate, column 3                            |
| 0x18ea | .w                | ~mem_ieColumn4~              | 0x0150 | instrument editor: x coordinate, column 4                            |
| 0x18ec | .l                |                              |        | *                                                                    |
| 0x1952 | .l                |                              |        | * handle, Supervisor window                                          |
| 0x1956 | .l                |                              |        | *                                                                    |
| 0x19d0 | .b × ?            |                              |        | (buffer)                                                             |
| 0x19d4 | .l                |                              |        | *                                                                    |
| 0x19d8 | .l                |                              |        | *                                                                    |
| 0x19dc | .b × 0x10         | ~mem_AsmExportProjectPrefix~ |        | AsmExport: Project prefix (remnant from Future Player)               |
| 0x19ec | .b                | ~mem_AsmExportFullTables~    |        | AsmExport flag, full tables (=0)                                     |
| 0x19ed | .b                | ~mem_AsmExportReqIndex~      |        | AsmExport: requester line selection index                            |
| 0x19ee | .w                |                              |        |                                                                      |
| 0x19f0 | .l × 0x10         | ~mem_AsmExportCommentPrefix~ |        | AsmExport: Comment prefix (remanant from Future Player)              |
| 0x1a00 | .b                | ~mem_AsmExportStrinNames~    |        | AsmExport flag, strip names (=0)                                     |
| 0x1a01 | .b                | ~mem_AsmExportLastReqIndex~  |        | AsmExoirt: last requester line (reference for 0x19ed)                |
| 0x1a02 | .b                |                              |        | AsmExport flag, absolute code (=0) (remnant from Future Player)      |
| 0x1a03 | .b                | ~mem_UnchordTargetScoreNum~  |        | unchord: target score number                                         |
| 0x1a04 |                   |                              |        | AsmExport                                                            |
| 0x1a54 | .b × ?            | ~mem_AsmExportReqStrBuffer~  |        | AsmExport: flag requester string buffer                              |
| 0x2224 | .l                |                              |        | track data line buffer                                               |
| 0x2242 | .l                | ~mem_ItemTable~              |        | * item changer: pointer to list                                      |
| 0x2246 | .w                |                              |        | (unchord)                                                            |
| 0x2248 | .l                | ~mem_UnchordTargetScore~     |        | * unchord: target score                                              |
| 0x224c | .w × ?            |                              |        | (unchord note data buffer?)                                          |
| 0x225e |                   |                              |        | (function 0x14 subroutines)                                          |
| 0x2260 | .l                | ~mem_SPatUnchordStart~       |        | * SP stored at start of unchord                                      |
| 0x226e | .b                |                              |        | (function 0x14 subroutines)                                          |
| 0x2276 | .l/b              |                              |        | (function 0x14 subroutines)                                          |
|--------+-------------------+------------------------------+--------+----------------------------------------------------------------------|


*** <<mm_weops>>Wave editor operations

Order of operations:

- adjust Result buffer length
- offset Src A wave data
- mix
- adjust amplitude (multiply by value and divide by 0x10)
- recalculate octave number

|--------+------+---------+------------+-----------------------------------------------------------|
| offset | size | name    | init value | description                                               |
|--------+------+---------+------------+-----------------------------------------------------------|
|    0x2 | .b   | ~op_SX~ |        0x0 | SX: offsets Src A wave data                               |
|    0x3 | .b   | ~op_SY~ |        0x0 | SY: signed offset value to add to Src A wave data points  |
|    0x4 | .b   | ~op_AM~ |       0x10 | AM: adjust Result wave data amplitude (0x10 == no change) |
|    0x5 | .b   | ~op_FQ~ |       0x10 | FQ: adjust Src A frequency (0x10 == no change)            |
|    0x6 | .b   | ~op_MX~ |        0x0 | MX: adjust mix of sources A (0x00) and B (0xff)           |
|    0x7 | .b   | ~op_RE~ |       0x10 | RE: adjusts Result buffer length (0x10 == 1:1 with Src A) |
|    0x8 | .b   |         |       0x10 |                                                           |
|    0x9 | .b   | ~op_PE~ |            | PE: playback period (* 0x10 + 0x96)                       |
|--------+------+---------+------------+-----------------------------------------------------------|

The octave number is calculated from the final length of the waveform.
Do note that the calculation routine can count down below zero to
"negative" octaves which will mess up the sample replay.

The octave number is calculated by taking the resulting buffer length
and shifting the bits right until the result is 2 or less, counting
down from 7 at each bitshift.  By this logic the buffer length
boundaries are as follows:

| octave | max. buffer length |   hex |
|--------+--------------------+-------|
|      7 |                  2 |   0x2 |
|      6 |                  5 |   0x5 |
|      5 |                 10 |   0xa |
|      4 |                 22 |  0x16 |
|      3 |                 46 |  0x2e |
|      2 |                 94 |  0x5e |
|      1 |                190 |  0xbe |
|      0 |                382 | 0x17e |

This will only affect buffers that have been created through the Wave
Editor operations.  Any raw samples directly loaded into the project
will receive octave number 0 which will make the player play the
sample as is without any playback period correction.


** Sound Channel Structure ("SCH")

One for each channel exists.  Some data, like DMA switching masks, are
pre-calculated to simplify the player routine.

|--------+-----------+---------------------+----------------------------------------------------------------------------------------------------------|
| offset | size      | name                | description                                                                                              |
|--------+-----------+---------------------+----------------------------------------------------------------------------------------------------------|
|    0x0 | .b        | ~sch_IsActive~      | True if channel has track data to play.                                                                  |
|    0x1 | .b        | ~sch_LogNote~       |                                                                                                          |
|    0x2 | .b        | ~sch_Gate~          | When false, triggers ADSR release.                                                                       |
|    0x3 | .b        | ~sch_Trig~          | Set true at every note unless the note is tied. Triggers ADSR and MGs. Set false at the end of UpdSCH(). |
|    0x4 | .l        | ~sch_PaulaPtr~      | *                                                                                                        |
|    0x8 | .w        | ~sch_DmaMask0~      | bitmask to write to DMACON to turn audio channel DMA off                                                 |
|    0xa | .w        | ~sch_DmaMask1~      | bitmask to write to DMACON to turn audio channel DMA on                                                  |
|    0xc | .l        | ~sch_Instrument~    | * pointer to current instrument                                                                          |
|   0x10 | .w        | ~sch_EnvLevel~      |                                                                                                          |
|   0x12 | .w        | ~sch_Period~        |                                                                                                          |
|   0x14 | .b        | ~sch_Amplitude~     |                                                                                                          |
|   0x15 | .b        |                     |                                                                                                          |
|   0x16 | .w        | ~sch_BShift~        | "Base Shift"                                                                                             |
|   0x18 | .w        | ~sch_DShift~        | "Dynamic Shift"                                                                                          |
|   0x1a | .l × 0x4  | ~sch_MgPars~        | MG parameters, "WORD Level BYTE DelayTime, status (u/d)"                                                 |
|   0x2a | .b        | ~sch_EnvStatus~     | Set true when ADSR TLevel reached. (attack -> decay)                                                     |
|   0x2b | .b        | ~sch_Duration~      |                                                                                                          |
|   0x2c | .l        | ~sch_TrackPtr~      | * play position at track                                                                                 |
|   0x30 | .b        | ~sch_TrackMode~     |                                                                                                          |
|        |           |                     |                                                                                                          |
|   0x36 | .l        | ~sch_OutWavePtr~    | *                                                                                                        |
|   0x3a | .w        | ~sch_OutWaveLen~    |                                                                                                          |
|   0x3c | .b        | ~sch_OutLogNote~    |                                                                                                          |
|   0x3d | .b        | ~sch_OutWaveNum~    |                                                                                                          |
|   0x3e | .b        | ~sch_OutOctave~     |                                                                                                          |
|   0x3f | .b        | ~sch_MustFetchWave~ |                                                                                                          |
|   0x40 | .l        | ~sch_OutWaveStruc~  | *                                                                                                        |
|   0x44 | .w        | ~sch_OutCycleSize~  |                                                                                                          |
|   0x46 | .l        | ~sch_OutWaveBuf~    | *                                                                                                        |
|   0x4a | .l        | ~sch_ChipBuf~       | * pointer to a 0x20 byte Chip RAM buffer                                                                 |
|   0x4e | .w        | ~sch_PrePeriod~     |                                                                                                          |
|   0x50 | .b        | ~sch_DynWaveValid~  | True, when dynamically generated wave doesn't need to be recalculated                                    |
|   0x51 | .b        | ~sch_IsStolen~      |                                                                                                          |
|   0x52 | .w        | ~sch_DynWaveSize~   | Size of dynamically generated wave in "ChipBuf"                                                          |
|   0x54 | .w        | ~sch_LastDShift~    | Previous calculated "dynamic shift"                                                                      |
|   0x56 | .b        | ~sch_ChnFlags~      |                                                                                                          |
|   0x57 | .b        | ~sch_FlagLR~        | 0x00 = left ; 0xff = right                                                                               |
|   0x58 | .b        | ~sch_FlagLH~        | 0x00 = "low" : 0xff = "high"                                                                             |
|   0x59 | .b        |                     |                                                                                                          |
|   0x5a | .w        | ~sch_Detune~        |                                                                                                          |
|   0x5c | .l        | ~sch_InitialTrkPtr~ | * pointer to start of track in the currently loaded score (song)                                         |
|   0x60 | .b        | ~sch_DynPerLsr~     | Bitwise left shift count for playback period correction of dynamically generated wave                    |
|   0x61 | .b        | ~sch_DynFreq~       | 2× nybble, advancing speeds for dynamic wave generation                                                  |
|   0x62 | .b        | ~sch_UpdRate~       |                                                                                                          |
|   0x63 | .b        | ~sch_Volume~        |                                                                                                          |
|   0x64 | .b × 0x40 | ~sch_VolTable~      |                                                                                                          |
|   0xa4 | .b        | ~sch_InsNum~        |                                                                                                          |
|   0xa5 | .b        |                     |                                                                                                          |
|   0xa6 | .b        | ~sch_FxTimeBase~    |                                                                                                          |
|   0xa7 | .b        | ~sch_FxTimeRnd~     |                                                                                                          |
|   0xa8 | .b        | ~sch_FxOffTime~     |                                                                                                          |
|   0xa9 | .b        | ~sch_Transpose~     |                                                                                                          |
|   0xaa | .w        | ~sch_GosubTblVec~   |                                                                                                          |
|   0xac | .w        | ~sch_LoopTblVec~    |                                                                                                          |
|   0xae | .l × 0x8  | ~sch_GosubTable~    |                                                                                                          |
|   0xce | .l × 0x8  | ~sch_LoopPtrTbl~    |                                                                                                          |
|   0xee | .l × 0x8  | ~sch_LoopTable~     |                                                                                                          |
|--------+-----------+---------------------+----------------------------------------------------------------------------------------------------------|


** Instrument structure

This is also the data structure used in MSOB and PVMS files.

~ins_SizeOf~ = 0x7a

|--------+-----------+-----------------+----------------------------------------------------------------------------|
| offset | size      | name            | description                                                                |
|--------+-----------+-----------------+----------------------------------------------------------------------------|
|    0x0 | .b × 0x10 | ~ins_Name~      |                                                                            |
|   0x10 | .b        | ~ins_SoundMode~ | mode (0 = looped sample; 1 = BShift; 2 = Dynamic; 3 >= single-shot sample) |
|   0x11 | .b        | ~ins_BShift~    | "Base shift"                                                               |
|   0x12 | .b        | ~ins_DShift~    | "Dynamic shift"                                                            |
|   0x13 | .b        | ~ins_Transpose~ | instrument transpose                                                       |
|   0x14 | .b × 0x8  | ~ins_WaveRefs~  | one byte for each octave, refers to the number of a wave/sample            |
|   0x1c | .b        | ~ins_DynFreq~   | Dynamic frequencies, two nybbles                                           |
|   0x1d | .b × 0x7  |                 | (padding)                                                                  |
|   0x24 | .b        | ~ins_EnvTrig~   | (not used)                                                                 |
|   0x25 | .b        | ~ins_EnvATime~  | ADSR: attack time                                                          |
|   0x26 | .b        | ~ins_EnvDTime~  | ADSR: decay time                                                           |
|   0x27 | .b        | ~ins_EnvRTime~  | ADSR: release time                                                         |
|   0x28 | .w        | ~ins_EnvTLevel~ | ADSR: peak level (MSB used, LSB zero)                                      |
|   0x2a | .w        | ~ins_EnvSLevel~ | ADSR: sustain level (MSB used, LSB zero)                                   |
|   0x2c | .w        | ~ins_EnvASlope~ | ADSR: attack slope (internal)                                              |
|   0x2e | .w        | ~ins_EnvDSlope~ | ADSR: decay slope (internal)                                               |
|   0x30 | .w        | ~ins_EnvRSlope~ | ADSR: release slope (internal)                                             |
|   0x32 |           | ~ins_Mg1~       | Modulation Generator 1                                                     |
|   0x44 |           | ~ins_Mg2~       | Modulation Generator 2                                                     |
|   0x56 |           | ~ins_Mg3~       | Modulation Generator 3                                                     |
|   0x68 |           | ~ins_Mg4~       | Modulation Generator 4                                                     |
|--------+-----------+-----------------+----------------------------------------------------------------------------|


*** TODO ADSR slope math to be extracted from the editor code!


*** MG structure

~mg_SizeOf~ = 0x12

|--------+------+-------------------+-----------------------------------------------------------------------------------------------|
| offset | size | name              | description                                                                                   |
|--------+------+-------------------+-----------------------------------------------------------------------------------------------|
|    0x0 | .b   | ~mg_Destination~  | parameter to be modulated: 0 = off; 1..7 = FM/AM/Bshift/Dshift/FM+/FM-/Dfreq                  |
|    0x1 | .b   | ~mg_Shape~        | boolean; modulaton waveform shape: 0 = triangle, non-zero = square                            |
|    0x2 | .b   | ~mg_TrigMode~     | boolean; trigger mode: 0 = retrigger at every note-on, non-zero = do not retrigger            |
|    0x3 | .b   | ~mg_SingleShot~   | boolean; single-shot mode: 0 = run generator continuously, non-zero = run cycle once and stop |
|    0x4 | .b   |                   | "Sg", not used                                                                                |
|    0x5 | .b   | ~mg_RvsOut~       | boolean; reverse operation: 0 = standard, non-zero = run modulation generator in reverse      |
|    0x6 | .b   | ~mg_DelayTime~    | non-zero = delay start of modulation                                                          |
|    0x7 | .b   | ~mg_HalfShift~    |                                                                                               |
|    0x8 | .b   | ~mg_QuarterShift~ |                                                                                               |
|    0x9 | .b   | ~mg_S1~           | time to reach modulation level from 0                                                         |
|    0xa | .b   | ~mg_S2~           | time to return to 0 from modulation level                                                     |
|    0xb | .b   |                   | not used?                                                                                     |
|    0xc | .w   | ~mg_Level~        | modulation level (user input is the most significant byte!)                                   |
|    0xe | .w   | ~mg_Slope1~       | MG slope (internal)                                                                           |
|   0x10 | .w   | ~mg_Slope2~       | MG slope (internal)                                                                           |
|--------+------+-------------------+-----------------------------------------------------------------------------------------------|


**** TODO MG slope math to be extracted from the editor code!


** Wave structure

There's two flavours of wave data structures used.  This first one
below is the "xplay" variety used in MSOBs.

~ww_SizeOfHeader~ = 0x18

|--------+---------------------+-------------------+---------------------------------------------------------|
| offset | size                | name              | description                                             |
|--------+---------------------+-------------------+---------------------------------------------------------|
|    0x0 | .b × 0x10           | ~ww_Name~         |                                                         |
|   0x10 | .w                  | ~ww_CycleSize~    | length of wave data                                     |
|   0x12 | .w                  | ~ww_Dummy~        | (not used)                                              |
|   0x14 | .b                  | ~ww_Octave~       | octave, should be 0..7                                  |
|   0x15 | .b                  | ~ww_FragFactor~   | (not used, but is calculated by some sample operations) |
|   0x16 | .b                  | ~ww_IsDoubleBufd~ | if non-zero, sample is double-buffered                  |
|   0x17 |                     |                   | (padding)                                               |
|   0x18 | .b × ~ww_CycleSize~ |                   | Wave data                                               |
|--------+---------------------+-------------------+---------------------------------------------------------|

The second variety below is the one used internally by the editor and
stored in the PVMS project files.

~ww_SizeOfHeader~ = 0x1c

|--------+---------------------+-------------------+----------------------------------------------------------|
| offset | size                | name              | description                                              |
|--------+---------------------+-------------------+----------------------------------------------------------|
|    0x0 | .b × 0x10           | ~ww_Name~         |                                                          |
|   0x10 | .l                  | ~ww_DataPtr~      | * pointer to wave data, ignored when loading PVMS        |
|   0x14 | .w                  | ~ww_CycleSize~    | length of wave data                                      |
|   0x16 | .w                  | ~ww_Dummy~        | (not used)                                               |
|   0x18 | .b                  | ~ww_IsDoubleBufd~ | if non-zero, sample is double-buffered                   |
|   0x19 | .b                  | ~ww_FragFactor~   | (not used, but is calculated by some sample operations!) |
|   0x1a | .b                  | ~ww_Octave~       | octave, should be 0..7                                   |
|   0x1b |                     |                   | (padding)                                                |
|   0x1c | .b × ~ww_CycleSize~ |                   | Wave data                                                |
|--------+---------------------+-------------------+----------------------------------------------------------|

Wave data is stored in PVMS files immediately after the header.  In
memory the wave data is stored in a separate chip RAM buffer.


** Track structure

In MSOBs tracks are headerless, but may have a 0x10 bytes long name
unless names are stripped. The following table is only applicable to
msed memory and PVMS project files.

~trk_SizeOfHeader~ = 0x20

|--------+-----------+-----------------+------------+---------------------------------------------------------------------------------------------|
| offset | size      | name            | init value | description                                                                                 |
|--------+-----------+-----------------+------------+---------------------------------------------------------------------------------------------|
|    0x0 | .b × 0x10 | ~trk_Name~      | "Unnamed " | (the rest of the name field are initially zeroes)                                           |
|   0x10 | .l        | ~trk_DataPtr~   |        0x0 | * pointer to track data buffer (stored but not used when loading PVMS)                      |
|   0x14 | .w        | ~trk_SizeOf~    |        0x2 | track size in bytes, including the end marker 0x8000                                        |
|   0x16 | .w        | ~trk_SizeOfBuf~ |        0x2 | track memory buffer size in bytes (stored but replaced with ~trk_SizeOf~ when loading PVMS) |
|   0x18 | .b        | ~trk_DefInstr~  |        0x0 | default instrument                                                                          |
|   0x19 | .b        | ~trk_EditMode~  |        0x0 | (see table below)                                                                           |
|   0x1a | .w        | ~trk_ViewStart~ |        0x0 | start point of track view, in bytes                                                         |
|   0x1c | .w        | ~trk_CursorPos~ |        0x0 | cursor position, in bytes                                                                   |
|   0x1e | .w        | ~trk_BlockMark~ |     0xffff | block mark, -0x1 of 0xffff when unmarked                                                    |
|--------+-----------+-----------------+------------+---------------------------------------------------------------------------------------------|

|------+----------------------|
| byte | editor mode          |
|------+----------------------|
| 0x00 | List mode            |
| 0x01 | Edit tone            |
| 0x02 | Edit duration        |
| 0x03 | Edit tone + duration |
| 0x04 | Insert mode          |
|------+----------------------|


*** Notes

Notes range from 0x02 (C-1) to 0x6d (B-9). In theory the notes can
range up to 0x7f ("F-;") but practical use ends by A-9 when the
dynamic waveforms reach the minimum length of two bytes.

|-------------+------+------+------+------+------+------+------+------+------|
| note/octave |    1 |    2 |    3 |    4 |    5 |    6 |    7 |    8 |    9 |
|-------------+------+------+------+------+------+------+------+------+------|
| C           | 0x02 | 0x0e | 0x1a | 0x26 | 0x32 | 0x3e | 0x4a | 0x56 | 0x62 |
| C#          | 0x03 | 0x0f | 0x1b | 0x27 | 0x33 | 0x3f | 0x4b | 0x57 | 0x63 |
| D           | 0x04 | 0x10 | 0x1c | 0x28 | 0x34 | 0x40 | 0x4c | 0x58 | 0x64 |
| Eb          | 0x05 | 0x11 | 0x1d | 0x29 | 0x35 | 0x41 | 0x4d | 0x59 | 0x65 |
| E           | 0x06 | 0x12 | 0x1e | 0x2a | 0x36 | 0x42 | 0x4e | 0x5a | 0x66 |
| F           | 0x07 | 0x13 | 0x1f | 0x2b | 0x37 | 0x43 | 0x4f | 0x5b | 0x67 |
| F#          | 0x08 | 0x14 | 0x20 | 0x2c | 0x38 | 0x44 | 0x50 | 0x5c | 0x68 |
| G           | 0x09 | 0x15 | 0x21 | 0x2d | 0x39 | 0x45 | 0x51 | 0x5d | 0x69 |
| Ab          | 0x0a | 0x16 | 0x22 | 0x2e | 0x3a | 0x46 | 0x52 | 0x5e | 0x6a |
| A           | 0x0b | 0x17 | 0x23 | 0x2f | 0x3b | 0x47 | 0x53 | 0x5f | 0x6b |
| Bb          | 0x0c | 0x18 | 0x24 | 0x30 | 0x3c | 0x48 | 0x54 | 0x60 | 0x6c |
| B           | 0x0d | 0x19 | 0x25 | 0x31 | 0x3d | 0x49 | 0x55 | 0x61 | 0x6d |
|-------------+------+------+------+------+------+------+------+------+------|


** Score structure

~sco_SizeOf~ = 0x32

|--------+-----------+--------------------+----------------------------------------------------------------------------------|
| offset | size      | name               | description                                                                      |
|--------+-----------+--------------------+----------------------------------------------------------------------------------|
|    0x0 | .b × 0x10 | ~sco_Name~         |                                                                                  |
|   0x10 | .b × 0x4  | ~sco_Tracks~       | one byte per channel                                                             |
|   0x14 | .b × 0x4  | ~sco_Tracks2~      | one byte per channel, alternate tracks (editor feature)                          |
|   0x18 | .w        | ~sco_Tempo~        | can be broken into two bytes, "Tempo Hi" and "Tempo Lo"                          |
|   0x19 | .b        | ~sco_TempoLo~      |                                                                                  |
|   0x1a | .b × 0x4  | ~sco_Instrs~       | one byte per channel                                                             |
|   0x1e | .b        | ~sco_DefInstr~     | default instrument                                                               |
|   0x1f | .b        | ~sco_Transpose~    | transpose (whole song)                                                           |
|   0x20 | .b        | ~sco_UpdReduction~ | update reduction, skip specified amount of timer ticks                           |
|   0x21 | .b        | ~sco_Repeat~       | boolean; 0 = play once, non-zero = play forever                                  |
|   0x22 | .b        | ~sco_FlangAlgo~    | flanger algorithm: 0 = off, 1-5 = select algo, >5 = off                          |
|   0x23 | .b        | ~sco_FlangSpeed~   | flanger speed: advance to next flanger row after specified number of timer ticks |
|   0x24 | .b        | ~sco_Volume~       | master volume: 0x00..0x3f                                                        |
|   0x25 | .b        |                    | (reserved?)                                                                      |
|   0x26 | .b × 0x4  | ~sco_FxBases~      | FxTimeBase: 0 = off (one byte per channel)                                       |
|   0x2a | .b × 0x4  | ~sco_FxRnds~       | FxRnd: 0 = off (one byte per channel)                                            |
|   0x2e | .b × 0x4  | ~sco_Volumes~      | channel volume, 0x00..0x3f (one byte per channel)                                |
|--------+-----------+--------------------+----------------------------------------------------------------------------------|


** "Function 0x14"

%4X   = four hexadecimal digits
%c    = a single character
%02bX = two-digit hexadecimal byte, with leading zero
%1bX  = a single digit of a hexadecimal byte
%ld   = decimal long
%s    = string
%-16s = string truncated to 16 characters
\n
\z

This function is called via a function pointer.  It is a printf()-like
string formatting function.

The following table lists offsets of stack space used via linked A4
register.

| offset | size |   init | description                                                                                                     |
|--------+------+--------+-----------------------------------------------------------------------------------------------------------------|
|  -0x3c | .l   |        |                                                                                                                 |
|  -0x36 | .b   |        | boolean                                                                                                         |
|  -0x34 | .b   |   0x00 | boolean                                                                                                         |
|  -0x32 | .b   |   0x00 | boolean                                                                                                         |
|  -0x30 | .b   |   0x00 | boolean                                                                                                         |
|  -0x2e | .b   |   0x00 | boolean                                                                                                         |
|  -0x2c | .b   |   0x00 | boolean                                                                                                         |
|  -0x2a | .b   |   0x00 | boolean                                                                                                         |
|  -0x28 | .b   |   0x00 | boolean                                                                                                         |
|  -0x26 | .b   |   0x20 | (byte storage)                                                                                                  |
|  -0x24 | .b   |   0x20 | (byte storage)                                                                                                  |
|  -0x22 | .b   |        | initialised from (-0x24), byte storage                                                                          |
|  -0x20 | .b   |   0x00 | boolean                                                                                                         |
|  -0x1e | .b   |   0x00 | boolean                                                                                                         |
|  -0x1c | .b   |   0x00 | boolean                                                                                                         |
|  -0x18 | .b   |   0x00 | boolean                                                                                                         |
|  -0x16 | .b   |   0x00 | boolean                                                                                                         |
|  -0x14 | .b   |   0x00 | boolean                                                                                                         |
|  -0x12 | .b   |   0x00 | storage, format byte for number formatting                                                                      |
|  -0x10 | .b   |   0x00 | boolean                                                                                                         |
|   -0xe | .b   |   0x00 | (byte storage)                                                                                                  |
|   -0xc | .w/b |        |                                                                                                                 |
|   -0xa | .w   | 0x0001 | (word storage)                                                                                                  |
|   -0x8 | .w   | 0x0000 | (word storage)                                                                                                  |
|   -0x6 | .w   | 0x0000 | (word storage)                                                                                                  |
|   -0x4 | .l   |   0x00 |                                                                                                                 |
|    0x0 | .l   |        | value of A4 to return with UNLNK                                                                                |
|    0x4 | .l   |     +4 | * return pointer for function 0x14                                                                              |
|    0x8 | .l   |        | * input string, moved to A0, subsequently iterated through in bytes                                             |
|    0xc | .l   |        | * extra input, moved to A3                                                                                      |
|   0x10 | .l   |        | * return buffer, moved to A2, byte at this address cleared before rts                                           |
|   0x14 | .l   |        | return buffer length, moved to D2, countdown register, subsequently handled as word, function returns when zero |
|   0x16 | .w   |        | lower word of return buffer length, used as addressing offset relative to (0x10)                                |


*** stack

| long       | "%ld"                                         |
| long       | "%ld"                                         |
| *str       | * input string                                |
| *rts       |                                               |
| 0x000000c8 | return buffer length                          |
| (0xd14,A5) | * return buffer                               |
| +(0x14)    | * pointer to stack -> "%ld"                   |
| +(0x14)    | * pointer to stack -> * input string          |
| *rts       | return pointer to where function 0x14 returns |
|------------+-----------------------------------------------|
| [A4]       | <- A4 points here                             |
| (0x3c)     |                                               |
| (0x38)     |                                               |
| (0x34)     |                                               |
| (0x30)     |                                               |
| (0x2c)     |                                               |
| (0x28)     |                                               |
| (0x24)     |                                               |
| (0x20)     |                                               |
| (0x1c)     |                                               |
| (0x18)     |                                               |
| (0x14)     |                                               |
| (0x10)     |                                               |
| (0x08)     |                                               |
| (0x04)     |                                               |
| (0x00)     |                                               |
|------------+-----------------------------------------------|
| [A6]       |                                               |
| [A3]       |                                               |
| [A2]       |                                               |
| [A1]       |                                               |
| [A0]       |                                               |
| [D7]       |                                               |
| [D6]       |                                               |
| [D5]       |                                               |
| [D4]       |                                               |
| [D3]       |                                               |
| [D2]       |                                               |
| [D1]       |                                               |
| [D0]       |                                               |


* msed patches

In addition of missing features msed does have plenty of bugs in it.
This section describes patches to fix or disable functionality that
may corrupt memory.


** Track editor: semitone up

The upper boundary of "semitone up" is too high and allows turning a
note into a track end marker.

Replace

: 4a48 : 0c 10 00 7f        cmpi.b  #0x7f,(A0)

with

: 4a48 : 0c 10 00 7e        cmpi.b  #0x7e,(A0)

The above fix will change the check to compare against the penultimate
possible note value instead of the last one.  The following
conditional branch instruction (bhi) will skip the next addition
instruction only if the byte value (note or SCODE) at A0 is higher.


** Supervisor: optimise scores

The score optimiser has a bug which may cause the score table scan to
end prematurely.

To make sure the whole score table is scanned, replace

: 6ade : 70 00              moveq      #0x0,D0

with 

: 6ade : 74 00              moveq      #0x0,D2


The patch above initialises the register D2 used as a counter instead
of the scratch buffer register D0.  The pointers loaded to D0 will
replace all the bits in each case, which means that initial clearing
of the register isn't required.


* msplay internals

** Memory map

This memory block is dynamically allocated at program start and the
pointer is kept in register A5.

mem_SizeOf = 0x41c

| offset | size      | name                  | description                                 |
|--------+-----------+-----------------------+---------------------------------------------|
|    0x0 | .l        | mem_pCleanUp          | * function, cleanup routine                 |
|    0x4 | .b        | mem_Instrument        | Instrument                                  |
|    0x5 | .b        | mem_FlangAlgo         | FlangAlgo                                   |
|    0x6 | .b        | mem_Transpose         | Transpose                                   |
|    0x7 | .b        | mem_FlangRate         | FlangRate                                   |
|    0x8 | .l        |                       |                                             |
|    0xc | .l        | mem_hOutput           | handle: output (dos.library)                |
|   0x10 | .l        |                       |                                             |
|   0x14 | .l        | mem_MessageString     | * message string                            |
|   0x18 | .l        | mem_pFuncFormatString | * function: string formatter                |
|   0x1c | .l        | mem_pSong             | * song data, points after magic word "MSOB" |
|   0x20 | .l        |                       | argc/argv                                   |
|   0x24 | .l        |                       | argc/argv                                   |
|   0x28 | .l        | mem_hInput            | handle: input (dos.library)                 |
|   0x2c | .l        | mem_spAtMainLoop      | stack pointer at start of main_loop()       |
|   0x30 | .l        |                       |                                             |
|   0x34 | .l        | mem_DosBase           | base address of dos.library                 |
|   0x38 | .w        | mem_Tempo             | TAHI & TALO                                 |
|   0x3a | .b        | mem_KeyBuffer         | keyboard read buffer, single byte           |
|  0x23c | .b × 0x78 | mem_InputBuffer       | keyboard read buffer, string                |
|  0x2b8 | .l        |                       |                                             |
|  0x2bc | .l        |                       |                                             |
|  0x2c4 |           |                       |                                             |
|  0x3f0 | .l        |                       | * function                                  |
|  0x3f4 | .l        |                       | * function                                  |
|  0x402 |           |                       |                                             |
|  0x40a |           |                       | string buffer (IntToStr())                  |


** File Operation Structure

This one is dynamically allocated and the pointer is kept in register
A2 during use.  Initial values from 0xc to 0x27 are produced
mathematically.

foStruc_SizeOf = 0x19a

| offset | size      | name          | description                 |
|--------+-----------+---------------+-----------------------------|
|    0x0 |           |               |                             |
|    0xc |           |               |                             |
|   0x60 | .l        |               | fib_DiskKey                 |
|   0x64 | .l        |               | fib_DiskEntryType           |
|   0x68 | .b × 0x6c |               | fib_FileName[108]           |
|   0xd4 | .l        |               | fib_Protection              |
|   0xd8 | .l        |               | fib_EntryType               |
|   0xdc | .l        | fo_fib_Size   | fib_Size                    |
|   0xe0 | .l        |               | fib_NumBlocks               |
|   0xe4 |           |               | fib_Date (struct DateStamp) |
|        | .b × 0x50 |               | fib_Comment[80]             |
|        | .w        |               | fib_OwnerUID                |
|        | .w        |               | fib_OwnerGID                |
|        | .b × 0x20 |               | fib_Reserved                |
|  0x184 | .l        | fo_FileLock   | file lock                   |
|  0x188 | .l        | fo_FileHandle | * file handle               |
|  0x18c | .l        | fo_           | file size                   |
|  0x190 | .l        |               |                             |
|  0x198 | .b        |               | flag                        |
|  0x199 | .b        |               | flag: File open/closed ?    |
